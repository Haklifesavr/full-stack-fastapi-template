version: "0.1"

topics:
  - name: "FastAPI - Application Configuration and Startup"
    paths:
      - '**/main.py'
      - '**/app.py'
      - '**/config.py'
      - '**/settings.py'
    policies:
      - title: "Use FastAPI BaseSettings for Configuration Management"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/settings/"
        description: |
          FastAPI projects must use `pydantic_settings.BaseSettings` for configuration management instead of manual environment variable loading.
        impact: |
          BaseSettings provides structured, typed, and maintainable configuration with automatic validation, minimizing deployment misconfigurations and improving environment-specific settings management.
        code_examples:
          - non_compliant: |
              # config.py
              import os
              
              DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://localhost/db")
              DEBUG_MODE = os.getenv("DEBUG", "false").lower() == "true"
              API_KEY = os.getenv("API_KEY")
          - compliant: |
              # config.py
              from pydantic_settings import BaseSettings

              class Settings(BaseSettings):
                  database_url: str = "postgresql://localhost/db"
                  debug_mode: bool = False
                  api_key: str

                  class Config:
                      env_file = ".env"

              settings = Settings()

      - title: "Configure FastAPI Application with Proper Metadata"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/metadata/"
        description: |
          FastAPI applications must be configured with proper title, description, version, and OpenAPI metadata.
        impact: |
          Proper application metadata improves API documentation, enables better client generation, and supports API discovery in enterprise environments.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()  # No metadata configuration
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI(
                  title="User Management API",
                  description="API for managing user accounts and authentication",
                  version="1.0.0",
                  openapi_tags=[
                      {"name": "users", "description": "User operations"},
                      {"name": "auth", "description": "Authentication"}
                  ]
              )

      - title: "Use FastAPI Lifespan Events for Startup/Shutdown Logic"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/events/"
        description: |
          Use FastAPI's lifespan context manager instead of deprecated startup/shutdown event handlers.
        impact: |
          Lifespan events ensure proper resource initialization and cleanup, prevent resource leaks, and support modern FastAPI patterns for application lifecycle management.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.on_event("startup")
              async def startup_event():
                  # Initialize database
                  pass

              @app.on_event("shutdown")
              async def shutdown_event():
                  # Close connections
                  pass
          - compliant: |
              from contextlib import asynccontextmanager
              from fastapi import FastAPI

              @asynccontextmanager
              async def lifespan(app: FastAPI):
                  # Startup
                  print("Starting up...")
                  yield
                  # Shutdown
                  print("Shutting down...")

              app = FastAPI(lifespan=lifespan)

  - name: "FastAPI - Async Design and Performance"
    paths:
      - '**/*.py'
    policies:
      - title: "Use `async def` for Route Handlers"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          All FastAPI route handlers must be declared using `async def`.
        impact: |
          Using `async def` unlocks non-blocking performance, allowing the server to handle thousands of concurrent connections. Synchronous handlers block the event loop, degrade performance, and negate FastAPI's primary advantage.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/sync")
              def get_data():
                  return {"message": "This blocks the event loop"}
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/async")
              async def get_data():
                  return {"message": "This uses async properly"}

      - title: "Avoid Blocking Calls Inside Async Route Handlers"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          Avoid using blocking operations such as `time.sleep()`, synchronous database calls, or file I/O inside `async def` FastAPI route functions.
        impact: |
          Blocking calls within async handlers freeze the event loop, degrade responsiveness, and cause bottlenecks under load. Using non-blocking equivalents ensures proper async execution and full utilization of FastAPI's concurrency model.
        code_examples:
          - non_compliant: |
              import time
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/block")
              async def blocking_handler():
                  time.sleep(5)  # blocks event loop
                  return {"status": "done"}
          - compliant: |
              import asyncio
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/non-block")
              async def non_blocking_handler():
                  await asyncio.sleep(5)  # non-blocking sleep
                  return {"status": "done"}

      - title: "Use Async Database Drivers with FastAPI"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          Use asynchronous database drivers (such as `asyncpg` for PostgreSQL) and libraries like `SQLAlchemy 2.x async` or `SQLModel` with async engines in FastAPI applications.
        impact: |
          Synchronous database access blocks the event loop and nullifies FastAPI's asynchronous benefits. Async drivers improve scalability by allowing I/O-bound database operations to run concurrently with other tasks.
        code_examples:
          - non_compliant: |
              import sqlite3
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  conn = sqlite3.connect("db.sqlite")
                  cursor = conn.cursor()
                  cursor.execute("SELECT * FROM users")
                  return {"users": cursor.fetchall()}
          - compliant: |
              from sqlmodel import SQLModel, select
              from sqlmodel.ext.asyncio.session import AsyncSession
              from fastapi import FastAPI, Depends
              from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker

              class User(SQLModel, table=True):
                  id: int
                  name: str

              engine = create_async_engine("sqlite+aiosqlite:///db.sqlite")
              async_session = async_sessionmaker(engine, class_=AsyncSession)

              async def get_session() -> AsyncSession:
                  async with async_session() as session:
                      yield session

              app = FastAPI()

              @app.get("/users")
              async def get_users(session: AsyncSession = Depends(get_session)):
                  result = await session.exec(select(User))
                  return {"users": result.all()}

      - title: "Avoid `asyncio.run()` in FastAPI Route Handlers"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          Inside FastAPI `async def` routes or dependencies, never call `asyncio.run()` or create nested event loops. Use `await` directly or offload via `create_task`.
        impact: |
          Nested event loops crash the server or raise `RuntimeError`. This misuse blocks the main loop and can lead to subtle deadlocks or process hangs under concurrency.
        code_examples:
          - non_compliant: |
              import asyncio
              from fastapi import FastAPI

              app = FastAPI()

              async def some_async_function():
                  return "result"

              @app.get("/nested")
              async def broken():
                  result = asyncio.run(some_async_function())  # invalid in async context
                  return {"result": result}
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              async def some_async_function():
                  return "result"

              @app.get("/safe")
              async def safe():
                  result = await some_async_function()
                  return {"result": result}

      - title: "Set Client-Side Timeouts for HTTP Requests in FastAPI"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/async-tests/"
        description: |
          All HTTPX or aiohttp requests in FastAPI applications must use an explicit timeout value.
        impact: |
          Lack of timeout results in hanging requests, degraded performance, and resource starvation. Explicit deadlines improve system resilience in FastAPI applications.
        code_examples:
          - non_compliant: |
              import httpx
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/external")
              async def call_external():
                  async with httpx.AsyncClient() as client:
                      response = await client.get("https://api.example.com/data")
                      return response.json()
          - compliant: |
              import httpx
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/external")
              async def call_external():
                  async with httpx.AsyncClient(timeout=5.0) as client:
                      response = await client.get("https://api.example.com/data")
                      return response.json()

  - name: "FastAPI - Dependency Injection and Services"
    paths:
      - '**/*.py'
    policies:
      - title: "Use FastAPI `Depends()` for Service Injection"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        description: |
          Use FastAPI's `Depends()` to inject dependencies such as database sessions, configuration objects, authentication logic, or service classes into route handlers.
        impact: |
          FastAPI dependency injection promotes modularity, reusability, testability, and loose coupling. `Depends()` enables FastAPI to manage lifecycle, caching, and overrides for testing.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              from sqlmodel import Session, create_engine

              engine = create_engine("sqlite:///db.sqlite")
              app = FastAPI()

              @app.get("/profile")
              async def profile():
                  session = Session(engine)
                  result = session.execute("SELECT * FROM users")
                  return {"user": result.fetchone()}
          - compliant: |
              from fastapi import FastAPI, Depends
              from sqlmodel import Session, create_engine

              engine = create_engine("sqlite:///db.sqlite")

              def get_session():
                  with Session(engine) as session:
                      yield session

              app = FastAPI()

              @app.get("/profile")
              async def profile(session: Session = Depends(get_session)):
                  user = session.execute("SELECT * FROM users").fetchone()
                  return {"user": user}

      - title: "Implement FastAPI Sub-Dependencies for Complex Logic"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/"
        description: |
          Use FastAPI sub-dependencies to break down complex dependency logic into smaller, composable functions.
        impact: |
          Sub-dependencies improve code organization, enable dependency reuse, and make complex authentication or authorization logic more maintainable in FastAPI applications.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Depends, HTTPException
              from fastapi.security import OAuth2PasswordBearer

              app = FastAPI()
              oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

              async def get_current_user(token: str = Depends(oauth2_scheme)):
                  # Complex logic mixed together
                  user = decode_token(token)
                  if not user:
                      raise HTTPException(status_code=401)
                  if not user.is_active:
                      raise HTTPException(status_code=400, detail="Inactive user")
                  if not user.has_permission("read"):
                      raise HTTPException(status_code=403, detail="Not enough permissions")
                  return user
          - compliant: |
              from fastapi import FastAPI, Depends, HTTPException
              from fastapi.security import OAuth2PasswordBearer

              app = FastAPI()
              oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

              async def get_token_user(token: str = Depends(oauth2_scheme)):
                  user = decode_token(token)
                  if not user:
                      raise HTTPException(status_code=401)
                  return user

              async def get_active_user(user = Depends(get_token_user)):
                  if not user.is_active:
                      raise HTTPException(status_code=400, detail="Inactive user")
                  return user

              async def get_current_user(user = Depends(get_active_user)):
                  if not user.has_permission("read"):
                      raise HTTPException(status_code=403, detail="Not enough permissions")
                  return user

      - title: "Use FastAPI Dependency Providers for Shared Resources"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        description: |
          Define dependency providers for shared resources like database connections, configuration, or external service clients in FastAPI applications.
        impact: |
          Dependency providers ensure consistent resource management, prevent resource leaks, and enable proper lifecycle management in FastAPI applications.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              import redis

              app = FastAPI()

              @app.get("/cache/{key}")
              async def get_cache(key: str):
                  client = redis.Redis(host='localhost', port=6379, db=0)  # New connection each time
                  value = client.get(key)
                  client.close()
                  return {"value": value}
          - compliant: |
              from fastapi import FastAPI, Depends
              import redis

              app = FastAPI()

              def get_redis_client():
                  client = redis.Redis(host='localhost', port=6379, db=0)
                  try:
                      yield client
                  finally:
                      client.close()

              @app.get("/cache/{key}")
              async def get_cache(key: str, redis_client = Depends(get_redis_client)):
                  value = redis_client.get(key)
                  return {"value": value}

  - name: "FastAPI - Request Validation and Serialization"
    paths:
      - '**/*.py'
    policies:
      - title: "Use Pydantic v2 Models for FastAPI Request Body Validation"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/body/"
        description: |
          Define FastAPI request body schemas using `pydantic.BaseModel` with Pydantic v2 syntax. Avoid using raw `dict`, `Any`, or loosely-typed parameters.
        impact: |
          Using Pydantic models ensures input validation is automatic, reliable, and self-documented. It eliminates manual validation logic and reduces runtime errors by enforcing strict type checks.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Request

              app = FastAPI()

              @app.post("/submit")
              async def submit_data(request: Request):
                  data = await request.json()
                  name = data["name"]
                  age = data["age"]
                  return {"message": f"Received {name}, age {age}"}
          - compliant: |
              from fastapi import FastAPI
              from pydantic import BaseModel

              app = FastAPI()

              class UserInput(BaseModel):
                  name: str
                  age: int

              @app.post("/submit")
              async def submit_data(data: UserInput):
                  return {"message": f"Received {data.name}, age {data.age}"}

      - title: "Define FastAPI Response Models Explicitly"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/response-model/"
        description: |
          All FastAPI route handlers must explicitly declare a response model using the `response_model` parameter.
        impact: |
          Specifying a `response_model` ensures only intended fields are included in API responses, protects sensitive data, and enforces output type consistency. It also improves OpenAPI documentation.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/user")
              async def get_user():
                  return {
                      "id": 1,
                      "name": "Alice",
                      "email": "alice@example.com",
                      "password": "secret123"  # should not be exposed
                  }
          - compliant: |
              from fastapi import FastAPI
              from pydantic import BaseModel

              app = FastAPI()

              class UserPublic(BaseModel):
                  id: int
                  name: str
                  email: str

              @app.get("/user", response_model=UserPublic)
              async def get_user():
                  return {
                      "id": 1,
                      "name": "Alice",
                      "email": "alice@example.com",
                      "password": "secret123"  # excluded automatically
                  }

      - title: "Use Pydantic Field Validators in FastAPI Models"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/body/"
        description: |
          Use Pydantic v2 field validators and constraints in FastAPI request/response models.
        impact: |
          Field validators provide custom validation logic, improve data quality, and ensure business rules are enforced at the API boundary.
        code_examples:
          - non_compliant: |
              from pydantic import BaseModel

              class User(BaseModel):
                  email: str
                  age: int
                  username: str
          - compliant: |
              from pydantic import BaseModel, Field, field_validator
              import re

              class User(BaseModel):
                  email: str = Field(..., pattern=r'^[^@]+@[^@]+\.[^@]+$')
                  age: int = Field(..., ge=0, le=120)
                  username: str = Field(..., min_length=3, max_length=20)

                  @field_validator('username')
                  @classmethod
                  def validate_username(cls, v):
                      if not re.match(r'^[a-zA-Z0-9_]+$', v):
                          raise ValueError('Username must contain only letters, numbers, and underscores')
                      return v

      - title: "Use FastAPI Query Parameter Validation"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/query-params-str-validations/"
        description: |
          Use FastAPI's `Query()` function to add validation and documentation to query parameters.
        impact: |
          Query parameter validation improves API robustness, provides better error messages, and enhances OpenAPI documentation with parameter constraints.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/items")
              async def read_items(skip: int = 0, limit: int = 10):
                  return {"skip": skip, "limit": limit}
          - compliant: |
              from fastapi import FastAPI, Query

              app = FastAPI()

              @app.get("/items")
              async def read_items(
                  skip: int = Query(0, ge=0, description="Number of items to skip"),
                  limit: int = Query(10, ge=1, le=100, description="Maximum number of items to return")
              ):
                  return {"skip": skip, "limit": limit}

      - title: "Use FastAPI Path Parameter Validation"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/"
        description: |
          Use FastAPI's `Path()` function to add validation and documentation to path parameters.
        impact: |
          Path parameter validation prevents invalid URLs from reaching route handlers, improves error handling, and enhances API documentation.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users/{user_id}")
              async def get_user(user_id: int):
                  return {"user_id": user_id}
          - compliant: |
              from fastapi import FastAPI, Path

              app = FastAPI()

              @app.get("/users/{user_id}")
              async def get_user(
                  user_id: int = Path(..., ge=1, description="The ID of the user to retrieve")
              ):
                  return {"user_id": user_id}

  - name: "FastAPI - Security and Authentication"
    paths:
      - '**/*.py'
    policies:
      - title: "Add Security Headers Middleware to FastAPI"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          FastAPI applications must include middleware that adds security headers like `Content-Security-Policy`, `X-Frame-Options`, and `X-Content-Type-Options`.
        impact: |
          Security headers middleware strengthens FastAPI application security by preventing common web vulnerabilities and improving browser-side security enforcement through automated header injection.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/")
              async def home():
                  return {"msg": "no headers set"}
          - compliant: |
              from fastapi import FastAPI
              from starlette.middleware.base import BaseHTTPMiddleware

              class SecurityHeadersMiddleware(BaseHTTPMiddleware):
                  async def dispatch(self, request, call_next):
                      response = await call_next(request)
                      response.headers["Content-Security-Policy"] = "default-src 'none'"
                      response.headers["X-Frame-Options"] = "DENY"
                      response.headers["X-Content-Type-Options"] = "nosniff"
                      return response

              app = FastAPI()
              app.add_middleware(SecurityHeadersMiddleware)

      - title: "Use FastAPI OAuth2 with JWT Bearer Tokens"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/security/"
        description: |
          Use FastAPI's `OAuth2PasswordBearer` with JWTs for authentication. Avoid insecure practices like plain tokens or manually parsing headers.
        impact: |
          OAuth2 with JWT provides a secure, stateless, and scalable mechanism for API authentication. It prevents token tampering, supports expiration, and integrates well with FastAPI's security system.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Request, HTTPException

              app = FastAPI()

              @app.get("/secure")
              async def secure_route(request: Request):
                  token = request.headers.get("Authorization")
                  if token != "supersecrettoken":
                      raise HTTPException(status_code=401, detail="Unauthorized")
                  return {"status": "ok"}
          - compliant: |
              from fastapi import Depends, FastAPI, HTTPException
              from fastapi.security import OAuth2PasswordBearer
              import jwt

              oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
              app = FastAPI()

              def verify_token(token: str = Depends(oauth2_scheme)):
                  try:
                      payload = jwt.decode(token, "secret_key", algorithms=["HS256"])
                      return payload
                  except jwt.PyJWTError:
                      raise HTTPException(status_code=401, detail="Invalid token")

              @app.get("/secure")
              async def secure_route(user = Depends(verify_token)):
                  return {"status": "ok", "user": user}

      - title: "Configure FastAPI CORS with Specific Origins"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/cors/"
        description: |
          Configure FastAPI CORS using `CORSMiddleware` with explicitly defined allowed origins instead of wildcards.
        impact: |
          Misconfigured CORS allows unauthorized websites to interact with your API. Restricting origins mitigates unauthorized access and prevents CSRF attacks in FastAPI applications.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              from fastapi.middleware.cors import CORSMiddleware

              app = FastAPI()
              app.add_middleware(
                  CORSMiddleware,
                  allow_origins=["*"],  # insecure wildcard
                  allow_credentials=True,
                  allow_methods=["*"],
                  allow_headers=["*"],
              )
          - compliant: |
              from fastapi import FastAPI
              from fastapi.middleware.cors import CORSMiddleware

              app = FastAPI()
              app.add_middleware(
                  CORSMiddleware,
                  allow_origins=["https://frontend.example.com", "https://admin.example.com"],
                  allow_credentials=True,
                  allow_methods=["GET", "POST", "PUT", "DELETE"],
                  allow_headers=["Authorization", "Content-Type"],
              )

      - title: "Validate File Uploads in FastAPI"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/request-files/"
        description: |
          FastAPI file uploads must validate MIME types and enforce maximum file size limits.
        impact: |
          Unvalidated file uploads can lead to security vulnerabilities, disk exhaustion, or malware propagation. Strict validation prevents exploitation via crafted files.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, File, UploadFile

              app = FastAPI()

              @app.post("/upload")
              async def upload(file: UploadFile = File(...)):
                  contents = await file.read()
                  return {"size": len(contents)}
          - compliant: |
              from fastapi import FastAPI, File, UploadFile, HTTPException

              app = FastAPI()

              @app.post("/upload")
              async def upload(file: UploadFile = File(...)):
                  allowed_types = ["image/png", "image/jpeg", "application/pdf"]
                  if file.content_type not in allowed_types:
                      raise HTTPException(status_code=415, detail="Unsupported file type")
                  
                  contents = await file.read()
                  if len(contents) > 5 * 1024 * 1024:  # 5MB limit
                      raise HTTPException(status_code=413, detail="File too large")
                  
                  return {"size": len(contents), "type": file.content_type}

      - title: "Use FastAPI Header Dependencies for Required Headers"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        description: |
          Use FastAPI's `Header()` dependency to declare and validate required HTTP headers.
        impact: |
          Header dependencies make required headers explicit in OpenAPI documentation, prevent invalid requests, and improve API contract enforcement.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Request

              app = FastAPI()

              @app.get("/items")
              async def get_items(request: Request):
                  version = request.headers.get("X-API-Version")
                  if not version:
                      return {"error": "Missing API version"}
                  return {"items": [], "version": version}
          - compliant: |
              from fastapi import FastAPI, Header

              app = FastAPI()

              @app.get("/items")
              async def get_items(x_api_version: str = Header(..., alias="X-API-Version")):
                  return {"items": [], "version": x_api_version}

  - name: "FastAPI - Documentation and OpenAPI"
    paths:
      - '**/*.py'
    policies:
      - title: "Add Comprehensive Documentation to FastAPI Endpoints"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/path-operation-configuration/"
        description: |
          Each FastAPI route should define `summary`, `description`, and `tags` in route decorators.
        impact: |
          Well-documented APIs improve developer experience, enable automated client generation, and reduce the need for external documentation.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  return [{"id": 1, "name": "Alice"}]
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get(
                  "/users",
                  summary="List all users",
                  description="Fetches and returns a list of all registered users in the system.",
                  tags=["users"]
              )
              async def get_users():
                  return [{"id": 1, "name": "Alice"}]

      - title: "Include Example Responses in FastAPI Routes"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/path-operation-configuration/"
        description: |
          FastAPI routes should include example responses using the `responses` parameter.
        impact: |
          Example responses improve API discoverability, help frontend developers understand expected data structures, and enhance OpenAPI documentation quality.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/status")
              async def get_status():
                  return {"status": "ok"}
          - compliant: |
              from fastapi import FastAPI
              from pydantic import BaseModel

              app = FastAPI()

              class StatusResponse(BaseModel):
                  status: str

              @app.get(
                  "/status",
                  response_model=StatusResponse,
                  responses={
                      200: {
                          "description": "Status check response",
                          "content": {
                              "application/json": {
                                  "example": {"status": "ok"}
                              }
                          }
                      }
                  }
              )
              async def get_status():
                  return {"status": "ok"}

      - title: "Document FastAPI Model Fields with Descriptions"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/body/"
        description: |
          Every field in Pydantic models used in FastAPI should include a description via `Field()`.
        impact: |
          Field-level descriptions improve generated documentation, enhance SDK generation, and provide clarity for API consumers.
        code_examples:
          - non_compliant: |
              from pydantic import BaseModel

              class User(BaseModel):
                  id: int
                  name: str
                  email: str
          - compliant: |
              from pydantic import BaseModel, Field

              class User(BaseModel):
                  id: int = Field(..., description="Unique user identifier")
                  name: str = Field(..., description="User's display name")
                  email: str = Field(..., description="User's email address")

      - title: "Configure FastAPI OpenAPI Tags for Route Organization"
        severity: low
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/metadata/"
        description: |
          Configure OpenAPI tags in FastAPI application initialization with name and description metadata.
        impact: |
          Proper tag configuration improves API documentation structure, making it easier for developers to navigate and understand different API sections.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()  # No OpenAPI tags configuration

              @app.get("/users", tags=["users"])  # Using tags without defining them
              async def get_users():
                  return []

              @app.post("/users", tags=["auth"])  # Inconsistent tag usage
              async def create_user():
                  return {}
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI(
                  openapi_tags=[
                      {"name": "users", "description": "User management operations"},
                      {"name": "auth", "description": "Authentication endpoints"}
                  ]
              )

              @app.get("/users", tags=["users"])
              async def get_users():
                  return []

              @app.post("/users", tags=["users"])
              async def create_user():
                  return {}

  - name: "FastAPI - Error Handling and HTTP Exceptions"
    paths:
      - '**/*.py'
    policies:
      - title: "Use FastAPI HTTPException for Error Responses"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/handling-errors/"
        description: |
          Use FastAPI's `HTTPException` instead of returning error dictionaries or raising generic Python exceptions in route handlers.
        impact: |
          HTTPException provides proper HTTP status codes, integrates with FastAPI's error handling system, and ensures consistent error response format.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users/{user_id}")
              async def get_user(user_id: int):
                  if user_id > 1000:
                      return {"error": "User not found"}  # Wrong approach
                  return {"user": "data"}
          - compliant: |
              from fastapi import FastAPI, HTTPException

              app = FastAPI()

              @app.get("/users/{user_id}")
              async def get_user(user_id: int):
                  if user_id > 1000:
                      raise HTTPException(status_code=404, detail="User not found")
                  return {"user": "data"}

      - title: "Implement Custom FastAPI Exception Handlers"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/handling-errors/"
        description: |
          Define custom exception handlers for `RequestValidationError` and `HTTPException` using FastAPI's `@app.exception_handler`.
        impact: |
          Custom exception handlers provide consistent error responses, hide implementation details, and improve API user experience by returning structured error information.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, HTTPException

              app = FastAPI()

              @app.get("/items/{item_id}")
              async def read_item(item_id: int):
                  if item_id > 100:
                      raise HTTPException(status_code=400, detail="Item ID too high")
                  return {"item_id": item_id}
              # No custom exception handlers
          - compliant: |
              from fastapi import FastAPI, HTTPException, Request
              from fastapi.responses import JSONResponse
              from fastapi.exceptions import RequestValidationError

              app = FastAPI()

              @app.exception_handler(HTTPException)
              async def http_exception_handler(request: Request, exc: HTTPException):
                  return JSONResponse(
                      status_code=exc.status_code,
                      content={"detail": exc.detail, "path": str(request.url)}
                  )

              @app.exception_handler(RequestValidationError)
              async def validation_exception_handler(request: Request, exc: RequestValidationError):
                  return JSONResponse(
                      status_code=422,
                      content={"detail": exc.errors(), "path": str(request.url)}
                  )

              @app.get("/items/{item_id}")
              async def read_item(item_id: int):
                  if item_id > 100:
                      raise HTTPException(status_code=400, detail="Item ID too high")
                  return {"item_id": item_id}

      - title: "Use FastAPI Status Code Constants"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/response-status-code/"
        description: |
          Use `fastapi.status` constants instead of numeric status codes in FastAPI route handlers and exceptions.
        impact: |
          Status code constants improve code readability, prevent typos, and make HTTP status codes more self-documenting in FastAPI applications.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, HTTPException

              app = FastAPI()

              @app.post("/users", status_code=201)
              async def create_user():
                  return {"user": "created"}

              @app.get("/users/{user_id}")
              async def get_user(user_id: int):
                  if user_id > 1000:
                      raise HTTPException(status_code=404, detail="User not found")
                  return {"user": "data"}
          - compliant: |
              from fastapi import FastAPI, HTTPException, status

              app = FastAPI()

              @app.post("/users", status_code=status.HTTP_201_CREATED)
              async def create_user():
                  return {"user": "created"}

              @app.get("/users/{user_id}")
              async def get_user(user_id: int):
                  if user_id > 1000:
                      raise HTTPException(
                          status_code=status.HTTP_404_NOT_FOUND, 
                          detail="User not found"
                      )
                  return {"user": "data"}

  - name: "FastAPI - Background Tasks and Job Processing"
    paths:
      - '**/*.py'
    policies:
      - title: "Use FastAPI BackgroundTasks for Non-Blocking Operations"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/background-tasks/"
        description: |
          Use FastAPI's `BackgroundTasks` for operations that should not block the response, such as sending emails or logging.
        impact: |
          Background tasks keep HTTP responses fast, improve user experience, and prevent timeouts by offloading heavy operations from the request-response cycle.
        code_examples:
          - non_compliant: |
              import time
              from fastapi import FastAPI

              app = FastAPI()

              @app.post("/notify")
              async def send_notification(email: str):
                  time.sleep(5)  # blocks response
                  print(f"Email sent to {email}")
                  return {"status": "email sent"}
          - compliant: |
              import time
              from fastapi import FastAPI, BackgroundTasks

              app = FastAPI()

              def send_email(user_email: str):
                  time.sleep(5)  # simulate email sending
                  print(f"Email sent to {user_email}")

              @app.post("/notify")
              async def send_notification(email: str, background_tasks: BackgroundTasks):
                  background_tasks.add_task(send_email, email)
                  return {"status": "queued"}

      - title: "Handle Background Task Errors in FastAPI"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/background-tasks/"
        description: |
          Background tasks in FastAPI should include proper error handling and logging.
        impact: |
          Error handling in background tasks prevents silent failures, enables debugging, and improves reliability of asynchronous operations.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, BackgroundTasks

              app = FastAPI()

              def send_email(email: str):
                  # Email sending logic without error handling
                  print(f"Sending email to {email}")

              @app.post("/notify")
              async def notify(email: str, background_tasks: BackgroundTasks):
                  background_tasks.add_task(send_email, email)
                  return {"status": "queued"}
          - compliant: |
              import logging
              from fastapi import FastAPI, BackgroundTasks

              app = FastAPI()
              logger = logging.getLogger(__name__)

              def send_email_with_error_handling(email: str):
                  try:
                      # Email sending logic
                      print(f"Sending email to {email}")
                      logger.info(f"Email sent successfully to {email}")
                  except Exception as e:
                      logger.error(f"Failed to send email to {email}: {str(e)}")

              @app.post("/notify")
              async def notify(email: str, background_tasks: BackgroundTasks):
                  background_tasks.add_task(send_email_with_error_handling, email)
                  return {"status": "queued"}

  - name: "FastAPI - Database Integration Patterns"
    paths:
      - '**/*.py'
    policies:
      - title: "Use FastAPI with SQLAlchemy 2.x Async Sessions"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/sql-databases/"
        description: |
          FastAPI database integration must use SQLAlchemy 2.x with async sessions and proper dependency injection.
        impact: |
          Async database sessions prevent blocking the event loop, enable better concurrency, and integrate properly with FastAPI's async model.
        code_examples:
          - non_compliant: |
              from sqlalchemy import create_engine
              from sqlalchemy.orm import sessionmaker
              from fastapi import FastAPI

              engine = create_engine("sqlite:///db.sqlite")
              SessionLocal = sessionmaker(bind=engine)

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  session = SessionLocal()
                  users = session.execute("SELECT * FROM users").fetchall()
                  session.close()
                  return {"users": users}
          - compliant: |
              from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
              from sqlalchemy.ext.asyncio import AsyncSession
              from fastapi import FastAPI, Depends

              engine = create_async_engine("sqlite+aiosqlite:///db.sqlite")
              SessionLocal = async_sessionmaker(engine, class_=AsyncSession)

              async def get_session() -> AsyncSession:
                  async with SessionLocal() as session:
                      yield session

              app = FastAPI()

              @app.get("/users")
              async def get_users(session: AsyncSession = Depends(get_session)):
                  result = await session.execute("SELECT * FROM users")
                  return {"users": result.fetchall()}

      - title: "Implement Database Connection Pooling in FastAPI"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/sql-databases/"
        description: |
          FastAPI applications must configure database connection pooling.
        impact: |
          Connection pooling improves performance by reusing database connections, reduces connection overhead, and prevents connection exhaustion in high-traffic FastAPI applications.
        code_examples:
          - non_compliant: |
              from sqlalchemy.ext.asyncio import create_async_engine
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  # Creating new engine each time
                  engine = create_async_engine("postgresql+asyncpg://user:pass@localhost/db")
                  # ... use engine
          - compliant: |
              from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
              from sqlalchemy.pool import QueuePool
              from fastapi import FastAPI

              # Configure engine with connection pooling
              engine = create_async_engine(
                  "postgresql+asyncpg://user:pass@localhost/db",
                  poolclass=QueuePool,
                  pool_size=20,
                  max_overflow=30,
                  pool_recycle=3600
              )

              app = FastAPI()

      - title: "Use Repository Pattern with FastAPI and Async Databases"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/sql-databases/"
        description: |
          Encapsulate database queries in repository classes when using FastAPI with async database access.
        impact: |
          Repository pattern improves separation of concerns, makes testing easier, and provides a clean abstraction layer between FastAPI routes and database operations.
        code_examples:
          - non_compliant: |
              from sqlmodel import SQLModel, select
              from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
              from fastapi import FastAPI, Depends

              class User(SQLModel, table=True):
                  id: int
                  name: str

              engine = create_async_engine("sqlite+aiosqlite:///db.sqlite")
              SessionLocal = async_sessionmaker(engine, class_=AsyncSession)

              async def get_session():
                  async with SessionLocal() as session:
                      yield session

              app = FastAPI()

              @app.get("/users/{user_id}")
              async def get_user(user_id: int, session: AsyncSession = Depends(get_session)):
                  # Direct database query in route handler
                  result = await session.execute(select(User).where(User.id == user_id))
                  user = result.scalar_one_or_none()
                  return user
          - compliant: |
              from sqlmodel import SQLModel, select
              from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
              from fastapi import FastAPI, Depends

              class User(SQLModel, table=True):
                  id: int
                  name: str

              engine = create_async_engine("sqlite+aiosqlite:///db.sqlite")
              SessionLocal = async_sessionmaker(engine, class_=AsyncSession)

              async def get_session():
                  async with SessionLocal() as session:
                      yield session

              class UserRepository:
                  def __init__(self, session: AsyncSession):
                      self.session = session

                  async def get_user_by_id(self, user_id: int):
                      result = await self.session.execute(select(User).where(User.id == user_id))
                      return result.scalar_one_or_none()

              app = FastAPI()

              @app.get("/users/{user_id}")
              async def get_user(user_id: int, session: AsyncSession = Depends(get_session)):
                  repo = UserRepository(session)
                  user = await repo.get_user_by_id(user_id)
                  return user

  - name: "FastAPI - Testing and Test Configuration"
    paths:
      - 'tests/**/*.py'
      - '**/test_*.py'
      - '**/*_test.py'
    policies:
      - title: "Use FastAPI TestClient for API Testing"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/testing/"
        description: |
          Use FastAPI's `TestClient` with pytest for testing API endpoints instead of external HTTP clients.
        impact: |
          TestClient provides in-process testing without requiring a running server, ensures proper dependency injection, and integrates seamlessly with FastAPI's architecture.
        code_examples:
          - non_compliant: |
              import requests

              def test_get_items():
                  response = requests.get("http://localhost:8000/items")
                  assert response.status_code == 200
          - compliant: |
              import pytest
              from fastapi.testclient import TestClient
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/items")
              async def get_items():
                  return {"items": []}

              client = TestClient(app)

              def test_get_items():
                  response = client.get("/items")
                  assert response.status_code == 200
                  assert response.json() == {"items": []}

      - title: "Override FastAPI Dependencies in Tests"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/testing/"
        description: |
          Use `app.dependency_overrides` to replace FastAPI dependencies with test doubles during testing.
        impact: |
          Dependency overrides enable isolated testing by replacing real dependencies with mocks, ensuring tests are fast, reliable, and don't affect external systems.
        code_examples:
          - non_compliant: |
              from fastapi.testclient import TestClient
              from fastapi import FastAPI, Depends

              def get_database():
                  return real_database_connection()

              app = FastAPI()

              @app.get("/users")
              async def get_users(db = Depends(get_database)):
                  return db.query_users()

              client = TestClient(app)

              def test_get_users():
                  # Uses real database
                  response = client.get("/users")
                  assert response.status_code == 200
          - compliant: |
              from fastapi.testclient import TestClient
              from fastapi import FastAPI, Depends

              def get_database():
                  return real_database_connection()

              def get_test_database():
                  return mock_database_connection()

              app = FastAPI()

              @app.get("/users")
              async def get_users(db = Depends(get_database)):
                  return db.query_users()

              app.dependency_overrides[get_database] = get_test_database
              client = TestClient(app)

              def test_get_users():
                  response = client.get("/users")
                  assert response.status_code == 200

      - title: "Test FastAPI Authentication and Security"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/testing/"
        description: |
          Write specific tests for FastAPI authentication and security mechanisms using TestClient.
        impact: |
          Security testing ensures authentication works correctly, validates error cases, and prevents security regressions in FastAPI applications.
        code_examples:
          - non_compliant: |
              from fastapi.testclient import TestClient

              def test_protected_endpoint():
                  response = client.get("/protected")
                  # No authentication testing
                  assert response.status_code == 200
          - compliant: |
              from fastapi.testclient import TestClient
              from fastapi import FastAPI, Depends
              from fastapi.security import OAuth2PasswordBearer

              oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
              app = FastAPI()

              @app.get("/protected")
              async def protected(token: str = Depends(oauth2_scheme)):
                  return {"message": "protected"}

              client = TestClient(app)

              def test_protected_endpoint_without_token():
                  response = client.get("/protected")
                  assert response.status_code == 401

              def test_protected_endpoint_with_token():
                  response = client.get("/protected", headers={"Authorization": "Bearer fake-token"})
                  assert response.status_code == 200

  - name: "FastAPI - Performance and Optimization"
    paths:
      - '**/*.py'
    policies:
      - title: "Enable FastAPI Response Compression"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Enable GZip compression middleware for FastAPI responses.
        impact: |
          Response compression reduces network overhead, improves response times for large JSON payloads, and enhances overall FastAPI application performance.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/large-data")
              async def get_large_data():
                  return {"data": ["item"] * 10000}  # Large uncompressed response
          - compliant: |
              from fastapi import FastAPI
              from fastapi.middleware.gzip import GZipMiddleware

              app = FastAPI()
              app.add_middleware(GZipMiddleware, minimum_size=1000)

              @app.get("/large-data")
              async def get_large_data():
                  return {"data": ["item"] * 10000}  # Compressed response

      - title: "Use FastAPI StreamingResponse for Large Data"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/custom-response/"
        description: |
          Use FastAPI's `StreamingResponse` for large files or data sets.
        impact: |
          Streaming responses prevent memory issues when serving large content, improve response times, and enable better resource utilization in FastAPI applications.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/large-file")
              async def download_large_file():
                  with open("large_file.csv", "rb") as f:
                      content = f.read()  # Loads entire file into memory
                  return content
          - compliant: |
              from fastapi import FastAPI
              from fastapi.responses import StreamingResponse

              app = FastAPI()

              @app.get("/large-file")
              async def download_large_file():
                  def generate():
                      with open("large_file.csv", "rb") as f:
                          while chunk := f.read(8192):
                              yield chunk
                  
                  return StreamingResponse(generate(), media_type="text/csv")

      - title: "Implement FastAPI Response Caching"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Implement caching mechanisms for FastAPI responses that don't change frequently.
        impact: |
          Response caching reduces database load, improves response times, and enhances overall application performance for frequently accessed data.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Depends
              from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
              from sqlalchemy import text

              engine = create_async_engine("sqlite+aiosqlite:///db.sqlite")
              SessionLocal = async_sessionmaker(engine, class_=AsyncSession)

              async def get_session():
                  async with SessionLocal() as session:
                      yield session

              app = FastAPI()

              @app.get("/expensive-data")
              async def get_expensive_data(session: AsyncSession = Depends(get_session)):
                  # Always hits database
                  result = await session.execute(text("SELECT id, name FROM users"))
                  rows = result.all()
                  return {"data": [{"id": row.id, "name": row.name} for row in rows]}
          - compliant: |
              from fastapi import FastAPI, Depends
              from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
              from sqlalchemy import text
              import redis
              import json

              engine = create_async_engine("sqlite+aiosqlite:///db.sqlite")
              SessionLocal = async_sessionmaker(engine, class_=AsyncSession)

              async def get_session():
                  async with SessionLocal() as session:
                      yield session

              app = FastAPI()
              redis_client = redis.Redis(host='localhost', port=6379, db=0)

              @app.get("/expensive-data")
              async def get_expensive_data(session: AsyncSession = Depends(get_session)):
                  # Check cache first
                  cached = redis_client.get("expensive_data")
                  if cached:
                      return json.loads(cached)
                  
                  # Hit database if not in cache
                  result = await session.execute(text("SELECT id, name FROM users"))
                  rows = result.all()
                  data = {"data": [{"id": row.id, "name": row.name} for row in rows]}
                  
                  # Cache for 5 minutes
                  redis_client.setex("expensive_data", 300, json.dumps(data))
                  return data

  - name: "FastAPI - API Versioning and Routing"
    paths:
      - '**/*.py'
    policies:
      - title: "Implement FastAPI API Versioning Strategy"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/bigger-applications/"
        description: |
          Implement API versioning in FastAPI using URL prefixes or APIRouter.
        impact: |
          API versioning enables backward compatibility, smooth migrations, and proper API evolution without breaking existing clients.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  return {"users": []}

              @app.get("/users-new")  # New endpoint for updated functionality
              async def get_users_new():
                  return {"users": [], "total": 0}
          - compliant: |
              from fastapi import FastAPI, APIRouter

              app = FastAPI()

              v1_router = APIRouter(prefix="/v1")
              v2_router = APIRouter(prefix="/v2")

              @v1_router.get("/users")
              async def get_users_v1():
                  return {"users": []}

              @v2_router.get("/users")
              async def get_users_v2():
                  return {"users": [], "total": 0}

              app.include_router(v1_router)
              app.include_router(v2_router)

      - title: "Use FastAPI APIRouter for Modular Route Organization"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/bigger-applications/"
        description: |
          Organize FastAPI routes using APIRouter.
        impact: |
          APIRouter enables modular organization, improves code maintainability, and allows for better separation of concerns in larger FastAPI applications.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  return {"users": []}

              @app.post("/users")
              async def create_user():
                  return {"user": "created"}

              @app.get("/products")
              async def get_products():
                  return {"products": []}

              @app.post("/products")
              async def create_product():
                  return {"product": "created"}
          - compliant: |
              from fastapi import FastAPI, APIRouter

              app = FastAPI()

              users_router = APIRouter(prefix="/users", tags=["users"])
              products_router = APIRouter(prefix="/products", tags=["products"])

              @users_router.get("/")
              async def get_users():
                  return {"users": []}

              @users_router.post("/")
              async def create_user():
                  return {"user": "created"}

              @products_router.get("/")
              async def get_products():
                  return {"products": []}

              @products_router.post("/")
              async def create_product():
                  return {"product": "created"}

              app.include_router(users_router)
              app.include_router(products_router)

      - title: "Implement FastAPI Route Dependencies for Shared Logic"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        description: |
          Use route-level dependencies in FastAPI to apply common logic across multiple endpoints.
        impact: |
          Route dependencies reduce code duplication, ensure consistent behavior across endpoints, and provide a clean way to apply cross-cutting concerns.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Header, HTTPException

              app = FastAPI()

              @app.get("/admin/users")
              async def admin_get_users(authorization: str = Header(...)):
                  if not authorization.startswith("Bearer admin-"):
                      raise HTTPException(status_code=403, detail="Admin access required")
                  return {"users": []}

              @app.get("/admin/settings")
              async def admin_get_settings(authorization: str = Header(...)):
                  if not authorization.startswith("Bearer admin-"):
                      raise HTTPException(status_code=403, detail="Admin access required")
                  return {"settings": {}}
          - compliant: |
              from fastapi import FastAPI, APIRouter, Header, HTTPException, Depends

              app = FastAPI()

              async def verify_admin_token(authorization: str = Header(...)):
                  if not authorization.startswith("Bearer admin-"):
                      raise HTTPException(status_code=403, detail="Admin access required")

              admin_router = APIRouter(
                  prefix="/admin",
                  dependencies=[Depends(verify_admin_token)]
              )

              @admin_router.get("/users")
              async def admin_get_users():
                  return {"users": []}

              @admin_router.get("/settings")
              async def admin_get_settings():
                  return {"settings": {}}

              app.include_router(admin_router)

  - name: "FastAPI - Request Processing and Middleware"
    paths:
      - '**/*.py'
    policies:
      - title: "Implement Custom FastAPI Middleware for Logging"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Implement custom middleware in FastAPI applications to automatically log request and response information including performance metrics.
        impact: |
          Logging middleware provides observability, helps with debugging, and enables monitoring of FastAPI application performance and usage patterns.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              import logging

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  logging.info("Getting users")  # Manual logging in each endpoint
                  return {"users": []}
          - compliant: |
              from fastapi import FastAPI
              from starlette.middleware.base import BaseHTTPMiddleware
              import logging
              import time

              class LoggingMiddleware(BaseHTTPMiddleware):
                  async def dispatch(self, request, call_next):
                      start_time = time.time()
                      response = await call_next(request)
                      process_time = time.time() - start_time
                      
                      logging.info(f"{request.method} {request.url.path} - {response.status_code} - {process_time:.3f}s")
                      return response

              app = FastAPI()
              app.add_middleware(LoggingMiddleware)

              @app.get("/users")
              async def get_users():
                  return {"users": []}

      - title: "Validate Request Size in FastAPI Middleware"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Implement middleware to validate request body size limits in FastAPI applications.
        impact: |
          Request size validation prevents DoS attacks, protects against memory exhaustion, and ensures server stability under load.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.post("/upload")
              async def upload(payload: dict):
                  return {"received": len(str(payload))}  # No size validation
          - compliant: |
              from fastapi import FastAPI
              from starlette.middleware.base import BaseHTTPMiddleware
              from starlette.responses import JSONResponse

              class RequestSizeMiddleware(BaseHTTPMiddleware):
                  def __init__(self, app, max_size: int = 1024 * 1024):  # 1MB default
                      super().__init__(app)
                      self.max_size = max_size

                  async def dispatch(self, request, call_next):
                      content_length = request.headers.get("content-length")
                      if content_length and int(content_length) > self.max_size:
                          return JSONResponse(
                              status_code=413,
                              content={"detail": "Request body too large"}
                          )
                      return await call_next(request)

              app = FastAPI()
              app.add_middleware(RequestSizeMiddleware, max_size=2*1024*1024)  # 2MB

  - name: "FastAPI - Static Files and Templates"
    paths:
      - '**/main.py'
      - '**/app.py'
    policies:
      - title: "Configure FastAPI Static Files Properly"
        severity: low
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/static-files/"
        description: |
          Use FastAPI's StaticFiles to serve static content with proper configuration and security headers.
        impact: |
          Proper static file configuration ensures efficient serving of assets, enables caching, and provides security for static content delivery.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              from fastapi.responses import FileResponse
              import os

              app = FastAPI()

              @app.get("/assets/{file_path}")
              async def serve_assets(file_path: str):
                  file_location = os.path.join("assets", file_path)
                  return FileResponse(file_location)
          - compliant: |
              from fastapi import FastAPI
              from fastapi.staticfiles import StaticFiles
              from starlette.middleware.base import BaseHTTPMiddleware

              class StaticSecurityMiddleware(BaseHTTPMiddleware):
                  async def dispatch(self, request, call_next):
                      response = await call_next(request)
                      if request.url.path.startswith("/static/"):
                          response.headers["Cache-Control"] = "public, max-age=3600"
                          response.headers["X-Content-Type-Options"] = "nosniff"
                      return response

              app = FastAPI()
              app.add_middleware(StaticSecurityMiddleware)
              app.mount("/static", StaticFiles(directory="static"), name="static")

      - title: "Use FastAPI Template Responses for HTML Content"
        severity: low
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/templates/"
        description: |
          Use FastAPI's template rendering capabilities with Jinja2 for HTML responses instead of string concatenation.
        impact: |
          Template rendering provides secure HTML generation, prevents XSS vulnerabilities, and enables maintainable frontend integration.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/profile/{username}")
              async def get_profile(username: str):
                  html_content = f"<html><body><h1>Hello {username}</h1></body></html>"
                  return html_content  # Unsafe string concatenation
          - compliant: |
              from fastapi import FastAPI, Request
              from fastapi.templating import Jinja2Templates
              from fastapi.responses import HTMLResponse

              app = FastAPI()
              templates = Jinja2Templates(directory="templates")

              @app.get("/profile/{username}", response_class=HTMLResponse)
              async def get_profile(request: Request, username: str):
                  return templates.TemplateResponse(
                      "profile.html", 
                      {"request": request, "username": username}
                  )

  - name: "FastAPI - Health Checks and Monitoring"
    paths:
      - '**/*.py'
    policies:
      - title: "Implement FastAPI Health Check Endpoints"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/path-operation-configuration/"
        description: |
          FastAPI applications that instantiate an app object must include health check endpoints.
        impact: |
          Health checks enable proper load balancing, monitoring, and automated deployment strategies by providing service health status.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  return {"users": []}
              # No health check endpoint
          - compliant: |
              from fastapi import FastAPI, status
              from pydantic import BaseModel

              app = FastAPI()

              class HealthCheck(BaseModel):
                  status: str
                  version: str

              @app.get(
                  "/health",
                  response_model=HealthCheck,
                  status_code=status.HTTP_200_OK,
                  tags=["health"]
              )
              async def health_check():
                  return HealthCheck(status="healthy", version="1.0.0")

              @app.get(
                  "/health/ready",
                  tags=["health"]
              )
              async def readiness_check():
                  # Check database connectivity, external services, etc.
                  return {"status": "ready"}

      - title: "Add Performance Monitoring to FastAPI"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          FastAPI applications must register performance monitoring middleware that tracks request processing time.
        impact: |
          Performance monitoring helps identify bottlenecks, enables proactive optimization, and provides insights into application behavior under load.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              import time

              app = FastAPI()

              @app.get("/slow-endpoint")
              async def slow_endpoint():
                  time.sleep(2)  # No performance monitoring
                  return {"data": "result"}
          - compliant: |
              from fastapi import FastAPI, Request
              from starlette.middleware.base import BaseHTTPMiddleware
              import time
              import logging

              logger = logging.getLogger(__name__)

              class PerformanceMiddleware(BaseHTTPMiddleware):
                  async def dispatch(self, request, call_next):
                      start_time = time.time()
                      response = await call_next(request)
                      process_time = time.time() - start_time
                      
                      # Log slow requests
                      if process_time > 1.0:
                          logger.warning(
                              f"Slow request: {request.method} {request.url.path} "
                              f"took {process_time:.3f}s"
                          )
                      
                      response.headers["X-Process-Time"] = str(process_time)
                      return response

              app = FastAPI()
              app.add_middleware(PerformanceMiddleware)

  - name: "FastAPI - Advanced Features and Patterns"
    paths:
      - '**/*.py'
    policies:
      - title: "Use FastAPI Event Handlers for Application Lifecycle"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/events/"
        description: |
          Use FastAPI lifespan events properly for resource initialization and cleanup instead of global initialization.
        impact: |
          Proper lifecycle management ensures resources are initialized correctly, prevents resource leaks, and enables graceful shutdowns.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              import redis

              # Global initialization outside of application lifecycle
              redis_client = redis.Redis(host='localhost', port=6379)

              app = FastAPI()

              @app.get("/cache/{key}")
              async def get_cache(key: str):
                  return {"value": redis_client.get(key)}
          - compliant: |
              from contextlib import asynccontextmanager
              from fastapi import FastAPI
              import redis

              @asynccontextmanager
              async def lifespan(app: FastAPI):
                  # Startup
                  redis_client = redis.Redis(host='localhost', port=6379)
                  app.state.redis = redis_client
                  yield
                  # Shutdown
                  redis_client.close()

              app = FastAPI(lifespan=lifespan)

              @app.get("/cache/{key}")
              async def get_cache(key: str):
                  return {"value": app.state.redis.get(key)}

      - title: "Implement Custom FastAPI Response Classes"
        severity: low
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/custom-response/"
        description: |
          Create custom response classes for specific content types or response formats in FastAPI.
        impact: |
          Custom response classes provide better control over response formatting, enable specific media types, and improve API flexibility.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/data.xml")
              async def get_xml_data():
                  xml_content = "<data><item>value</item></data>"
                  return xml_content  # Wrong content type
          - compliant: |
              from fastapi import FastAPI
              from fastapi.responses import Response

              class XMLResponse(Response):
                  media_type = "application/xml"

              app = FastAPI()

              @app.get("/data.xml", response_class=XMLResponse)
              async def get_xml_data():
                  xml_content = "<data><item>value</item></data>"
                  return XMLResponse(content=xml_content)

      - title: "Use FastAPI Form Data Validation"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/request-forms/"
        description: |
          Use FastAPI's Form validation for HTML form submissions with proper Pydantic models.
        impact: |
          Form validation ensures data integrity, provides consistent validation across different input types, and integrates well with FastAPI's validation system.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Form

              app = FastAPI()

              @app.post("/submit-form")
              async def submit_form(
                  username: str = Form(...),
                  password: str = Form(...),
                  email: str = Form(...)
              ):
                  # No validation beyond basic types
                  return {"username": username, "email": email}
          - compliant: |
              from fastapi import FastAPI, Form, Depends
              from pydantic import BaseModel, EmailStr, Field, field_validator
              import re

              class UserForm(BaseModel):
                  username: str = Field(..., min_length=3, max_length=20)
                  password: str = Field(..., min_length=8)
                  email: EmailStr

                  @field_validator('username')
                  @classmethod
                  def validate_username(cls, v):
                      if not re.match(r'^[a-zA-Z0-9_]+$', v):
                          raise ValueError('Invalid username format')
                      return v

              async def form_data(
                  username: str = Form(...),
                  password: str = Form(...),
                  email: str = Form(...)
              ) -> UserForm:
                  return UserForm(username=username, password=password, email=email)

              app = FastAPI()

              @app.post("/submit-form")
              async def submit_form(form: UserForm = Depends(form_data)):
                  return {"username": form.username, "email": form.email}
