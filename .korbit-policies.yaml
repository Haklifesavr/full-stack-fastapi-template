version: "0.1"

topics:
  - name: "FastAPI - Project Setup and Environment Management"
    paths:
      - '**/*.py'
      - '**/*.toml'
      - '**/*.txt'
      - '**/*.in'
    policies:
      - title: "Require Dependency Configuration Files (e.g. `pyproject.toml`, `requirements.in`, or lock files)"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/deployment/dependencies/"
        description: |
          Projects must declare and manage Python dependencies using verifiable configuration files such as `pyproject.toml`, `requirements.in`, and lock files like `poetry.lock` or `requirements.txt` compiled via `pip-compile`.
        impact: |
          Requiring standard dependency configuration files ensures reproducibility, prevents dependency conflicts, and supports automated tooling in CI/CD pipelines. These files are verifiable from source control and enforce consistency across development environments.
        code_examples:
          - non_compliant: |
              # requirements.txt generated via pip freeze
              flask==2.3.2
              fastapi==0.100.0
              uvicorn==0.22.0

              # No pyproject.toml or requirements.in or lock file
          - compliant: |
              # pyproject.toml using poetry
              [tool.poetry.dependencies]
              python = "^3.10"
              fastapi = "^0.100.0"
              uvicorn = "^0.22.0"

              # poetry.lock file should be committed

              # OR using pip-tools:
              # requirements.in
              fastapi
              uvicorn

              # requirements.txt (generated by pip-compile) is also present

      - title: "Store Secrets in `.env` Files Not Source Code"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/settings/"
        description: |
          Hardcoding credentials, tokens, or API keys directly in the source code is prohibited. Instead, secrets must be stored in `.env` files and accessed through environment variable loaders.
        impact: |
          Storing secrets in source code poses a major security risk and can lead to credential leaks, especially in public repositories. Using `.env` files ensures sensitive data remains local, configurable, and excluded from version control.
        code_examples:
          - non_compliant: |
              # main.py
              API_KEY = "sk-live-12345abcde"
              DATABASE_URL = "postgresql://user:password@localhost/db"

              def get_api_key():
                  return API_KEY
          - compliant: |
              # main.py
              import os
              from pydantic import BaseSettings

              class Settings(BaseSettings):
                  api_key: str
                  database_url: str
                  
                  class Config:
                      env_file = ".env"

              settings = Settings()

      - title: "Load Configs per Environment Using `BaseSettings`"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/settings/"
        description: |
          Projects must use `pydantic.BaseSettings` or a similar configuration pattern to manage environment-specific settings.
        impact: |
          Hardcoding configuration values prevents flexibility across environments (dev/stage/prod) and limits testability. Using `BaseSettings` provides structured, typed, and maintainable configuration, minimizing deployment misconfigurations.
        code_examples:
          - non_compliant: |
              # config.py
              import os
              
              DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://localhost/db")
              DEBUG_MODE = os.getenv("DEBUG", "false").lower() == "true"
              REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
          - compliant: |
              # config.py
              from pydantic import BaseSettings

              class Settings(BaseSettings):
                  database_url: str = "postgresql://localhost/db"
                  debug_mode: bool = False
                  redis_host: str = "localhost"

                  class Config:
                      env_file = ".env"

              settings = Settings()

      - title: "Pin Dependencies Using Version Constraints"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/deployment/dependencies/"
        description: |
          All dependencies in configuration files must use specific version constraints rather than wildcards or open-ended ranges.
        impact: |
          Locking versions prevents regressions caused by upstream dependency changes. It ensures reproducible builds and predictable deployment behavior.
        code_examples:
          - non_compliant: |
              # pyproject.toml
              [tool.poetry.dependencies]
              fastapi = "*"
              uvicorn = ">=0.20"
              sqlalchemy = ">=1.4"
          - compliant: |
              # pyproject.toml  
              [tool.poetry.dependencies]
              fastapi = "^0.110.0"
              uvicorn = "^0.22.0"
              sqlalchemy = "^2.0.0"

  - name: "FastAPI - Async Design and Performance"
    paths:
      - '**/*.py'
    policies:
      - title: "Use `async def` for Route Handlers"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          All FastAPI route handlers must be declared using `async def`.
        impact: |
          Using `async def` unlocks non-blocking performance, allowing the server to handle thousands of concurrent connections. Synchronous handlers block the event loop, degrade performance, and negate FastAPI's primary advantage.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/sync")
              def get_data():
                  return {"message": "This blocks the event loop"}
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/async")
              async def get_data():
                  return {"message": "This uses async properly"}

      - title: "Avoid Blocking Calls Inside Async Context"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          Avoid using blocking operations such as `time.sleep()`, synchronous database calls, or file I/O inside `async def` functions.
        impact: |
          Blocking calls within async handlers freeze the event loop, degrade responsiveness, and cause bottlenecks under load. Using non-blocking equivalents ensures proper async execution and full utilization of FastAPI's concurrency model.
        code_examples:
          - non_compliant: |
              import time
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/block")
              async def blocking_handler():
                  time.sleep(5)  # blocks event loop
                  return {"status": "done"}
          - compliant: |
              import asyncio
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/non-block")
              async def non_blocking_handler():
                  await asyncio.sleep(5)  # non-blocking sleep
                  return {"status": "done"}

      - title: "Use Async Database Drivers and Libraries"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          Use asynchronous database drivers (such as `asyncpg` for PostgreSQL) and libraries like `SQLAlchemy 2.x async` or `SQLModel` with async engines. Avoid synchronous database clients within `async def` routes.
        impact: |
          Synchronous database access blocks the event loop and nullifies FastAPI's asynchronous benefits. Async drivers improve scalability by allowing I/O-bound database operations to run concurrently with other tasks.
        code_examples:
          - non_compliant: |
              import sqlite3
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  conn = sqlite3.connect("db.sqlite")
                  cursor = conn.cursor()
                  cursor.execute("SELECT * FROM users")
                  return {"users": cursor.fetchall()}
          - compliant: |
              from sqlmodel import SQLModel, select
              from sqlmodel.ext.asyncio.session import AsyncSession
              from fastapi import FastAPI, Depends
              from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker

              class User(SQLModel, table=True):
                  id: int
                  name: str

              engine = create_async_engine("sqlite+aiosqlite:///db.sqlite")
              async_session = async_sessionmaker(engine, class_=AsyncSession)

              async def get_session() -> AsyncSession:
                  async with async_session() as session:
                      yield session

              app = FastAPI()

              @app.get("/users")
              async def get_users(session: AsyncSession = Depends(get_session)):
                  result = await session.exec(select(User))
                  return {"users": result.all()}

      - title: "Avoid `asyncio.run()` or Nested Event Loops in FastAPI Context"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          Inside `async def` FastAPI routes or dependencies, never call `asyncio.run()` or create nested event loops. Use `await` directly or offload via `create_task`.
        impact: |
          Nested event loops crash the server or raise `RuntimeError`. This misuse blocks the main loop and can lead to subtle deadlocks or process hangs under concurrency.
        code_examples:
          - non_compliant: |
              import asyncio
              from fastapi import FastAPI

              app = FastAPI()

              async def some_async_function():
                  return "result"

              @app.get("/nested")
              async def broken():
                  result = asyncio.run(some_async_function())  # invalid in async context
                  return {"result": result}
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              async def some_async_function():
                  return "result"

              @app.get("/safe")
              async def safe():
                  result = await some_async_function()
                  return {"result": result}

      - title: "Never Use `threading.Thread` in Async FastAPI Apps"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/async/"
        description: |
          Avoid using `threading.Thread` or synchronous parallelism in FastAPI apps. Use `asyncio.create_task()` or background queues instead.
        impact: |
          Threads block the event loop, can corrupt async state, and introduce concurrency issues. Use coroutine-based patterns to preserve async flow.
        code_examples:
          - non_compliant: |
              import threading
              from fastapi import FastAPI

              app = FastAPI()

              def slow_op():
                  return "done"

              @app.get("/block")
              async def handler():
                  threading.Thread(target=slow_op).start()
                  return {"status": "started"}
          - compliant: |
              import asyncio
              from fastapi import FastAPI

              app = FastAPI()

              async def slow_op():
                  return "done"

              @app.get("/async")
              async def handler():
                  asyncio.create_task(slow_op())
                  return {"status": "dispatched"}

      - title: "Set Client-Side Timeouts for All Outbound HTTP Requests"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/async-tests/"
        description: |
          All HTTPX or aiohttp requests must use an explicit timeout value.
        impact: |
          Lack of timeout results in hanging requests, degraded performance, and resource starvation. Explicit deadlines improve system resilience.
        code_examples:
          - non_compliant: |
              import httpx
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/external")
              async def call_external():
                  async with httpx.AsyncClient() as client:
                      response = await client.get("https://api.example.com/data")
                      return response.json()
          - compliant: |
              import httpx
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/external")
              async def call_external():
                  async with httpx.AsyncClient(timeout=5.0) as client:
                      response = await client.get("https://api.example.com/data")
                      return response.json()

  - name: "FastAPI - Dependency Injection and Services"
    paths:
      - '**/*.py'
    policies:
      - title: "Use `Depends()` for Service Injection"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        description: |
          Use FastAPI's `Depends()` to inject dependencies such as database sessions, configuration objects, authentication logic, or service classes into route handlers. Avoid manual instantiation or global singletons inside endpoints.
        impact: |
          Dependency injection promotes modularity, reusability, testability, and loose coupling. `Depends()` enables FastAPI to manage lifecycle, caching, and overrides for testing and simplifies clean architecture implementation.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              from sqlmodel import Session, create_engine

              engine = create_engine("sqlite:///db.sqlite")
              app = FastAPI()

              @app.get("/profile")
              async def profile():
                  session = Session(engine)
                  result = session.execute("SELECT * FROM users")  # manual query
                  return {"user": result.fetchone()}
          - compliant: |
              from fastapi import FastAPI, Depends
              from sqlmodel import Session, create_engine

              engine = create_engine("sqlite:///db.sqlite")

              def get_session():
                  with Session(engine) as session:
                      yield session

              app = FastAPI()

              @app.get("/profile")
              async def profile(session: Session = Depends(get_session)):
                  user = session.execute("SELECT * FROM users").fetchone()
                  return {"user": user}

      - title: "Avoid Global State for Shared Dependencies"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        description: |
          Avoid defining mutable global objects (e.g., database sessions, clients, config instances) that are directly accessed from route handlers. Use dependency injection with `Depends()` to provide these services instead.
        impact: |
          Global state leads to tight coupling, makes testing difficult, and may cause race conditions or data leakage in asynchronous contexts. Dependency injection ensures controlled instantiation and improves code maintainability and testability.
        code_examples:
          - non_compliant: |
              from sqlmodel import Session, create_engine
              from fastapi import FastAPI

              engine = create_engine("sqlite:///db.sqlite")
              session = Session(engine)  # global session

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  return session.exec("SELECT * FROM users")  # unsafe global access
          - compliant: |
              from sqlmodel import Session, create_engine
              from fastapi import FastAPI, Depends

              engine = create_engine("sqlite:///db.sqlite")

              def get_session():
                  with Session(engine) as session:
                      yield session

              app = FastAPI()

              @app.get("/users")
              async def get_users(session: Session = Depends(get_session)):
                  return session.exec("SELECT * FROM users")

      - title: "Scope Mutable Objects to Prevent Concurrency Issues in FastAPI Dependencies"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        description: |
          Do not define mutable objects like lists, dicts, or sets at the global/module level in FastAPI applications. Instead, scope them within dependency functions or use proper concurrency-safe alternatives through the dependency injection system.
        impact: |
          Global shared state can be mutated by concurrent requests, causing data corruption, hard-to-debug behavior, or memory leaks. Proper dependency injection scoping ensures thread-safe and request-isolated state management in FastAPI applications with modular service architecture.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()
              users = []  # global mutable list

              @app.post("/user")
              async def add_user(name: str):
                  users.append(name)  # unsafe concurrent access
                  return {"users": users}
          - compliant: |
              from fastapi import FastAPI, Depends

              app = FastAPI()

              def get_user_storage():
                  return []

              @app.post("/user")
              async def add_user(name: str, user_storage: list = Depends(get_user_storage)):
                  user_storage.append(name)
                  return {"users": user_storage}

  - name: "FastAPI - Request Validation and Serialization"
    paths:
      - '**/*.py'
    policies:
      - title: "Use Pydantic Models for Request Body Validation"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/body/"
        description: |
          Define request body schemas using `pydantic.BaseModel`. Avoid using raw `dict`, `Any`, or loosely-typed parameters in route functions.
        impact: |
          Using Pydantic models ensures input validation is automatic, reliable, and self-documented. It eliminates manual validation logic and reduces runtime errors by enforcing strict type checks and field requirements.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Request

              app = FastAPI()

              @app.post("/submit")
              async def submit_data(request: Request):
                  data = await request.json()
                  name = data["name"]
                  age = data["age"]
                  return {"message": f"Received {name}, age {age}"}
          - compliant: |
              from fastapi import FastAPI
              from pydantic import BaseModel

              app = FastAPI()

              class UserInput(BaseModel):
                  name: str
                  age: int

              @app.post("/submit")
              async def submit_data(data: UserInput):
                  return {"message": f"Received {data.name}, age {data.age}"}

      - title: "Define Response Models Explicitly in Routes"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/response-model/"
        description: |
          All route handlers must explicitly declare a response model using the `response_model` parameter.
        impact: |
          Specifying a `response_model` ensures only the intended fields are included in API responses, protects sensitive data, and enforces output type consistency across the application. It also improves OpenAPI documentation.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/user")
              async def get_user():
                  return {
                      "id": 1,
                      "name": "Alice",
                      "email": "alice@example.com",
                      "password": "secret123"  # should not be exposed
                  }
          - compliant: |
              from fastapi import FastAPI
              from pydantic import BaseModel

              app = FastAPI()

              class UserPublic(BaseModel):
                  id: int
                  name: str
                  email: str

              @app.get("/user", response_model=UserPublic)
              async def get_user():
                  return {
                      "id": 1,
                      "name": "Alice",
                      "email": "alice@example.com",
                      "password": "secret123"  # excluded automatically
                  }

      - title: "Do Not Return Raw ORM Objects from Endpoints"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/response-model/"
        description: |
          API routes must return response models or serializable Pydantic objects. Do not return raw ORM models directly.
        impact: |
          Returning ORM instances risks leaking internal fields and breaks OpenAPI contracts. Proper response models ensure type safety and external correctness.
        code_examples:
          - non_compliant: |
              from sqlmodel import Session
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/user")
              async def get_user(session: Session):
                  user = session.query(User).first()
                  return user  # raw ORM object
          - compliant: |
              from sqlmodel import Session
              from fastapi import FastAPI
              from pydantic import BaseModel

              app = FastAPI()

              class UserPublic(BaseModel):
                  id: int
                  name: str
                  email: str

              @app.get("/user", response_model=UserPublic)
              async def get_user(session: Session):
                  user = session.query(User).first()
                  return UserPublic.from_orm(user)

      - title: "Avoid Accepting `Any` or Loose `dict` Types in Request Models"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/body/"
        description: |
          Pydantic models should use strongly typed fields. Avoid accepting `Any`, `dict`, or `object` fields unless absolutely necessary and validated downstream.
        impact: |
          Weak typing leads to hidden bugs, schema drift, and security gaps. Strong contracts allow better linting, autocompletion, and runtime enforcement.
        code_examples:
          - non_compliant: |
              from pydantic import BaseModel
              from typing import Any

              class Input(BaseModel):
                  payload: dict  # weak typing
                  metadata: Any  # no validation
          - compliant: |
              from pydantic import BaseModel

              class Payload(BaseModel):
                  message: str
                  count: int

              class Metadata(BaseModel):
                  source: str
                  timestamp: int

              class Input(BaseModel):
                  payload: Payload
                  metadata: Metadata

      - title: "Validate Enum and Constant Fields Using Pydantic"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/body/"
        description: |
          Any status, role, or type field should be represented using `Enum` types in request/response models.
        impact: |
          Enums ensure data correctness, prevent typos, and generate better OpenAPI documentation. This improves both backend and client validation.
        code_examples:
          - non_compliant: |
              from pydantic import BaseModel

              class User(BaseModel):
                  role: str  # accepts anything
                  status: str  # no validation
          - compliant: |
              from enum import Enum
              from pydantic import BaseModel

              class Role(str, Enum):
                  admin = "admin"
                  user = "user"
                  moderator = "moderator"

              class Status(str, Enum):
                  active = "active"
                  inactive = "inactive"

              class User(BaseModel):
                  role: Role
                  status: Status

  - name: "FastAPI - Security and Authentication"
    paths:
      - '**/*.py'
    policies:
      - title: "Use OAuth2 with JWT Bearer Tokens"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/security/"
        description: |
          Use FastAPI's `OAuth2PasswordBearer` with JWTs for authentication. Avoid insecure practices like plain tokens, API keys in query strings, or manually parsing headers without validation.
        impact: |
          OAuth2 with JWT provides a secure, stateless, and scalable mechanism for API authentication. It prevents token tampering, supports expiration, and allows for secure user/session management across distributed systems.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Request

              app = FastAPI()

              @app.get("/secure")
              async def secure_route(request: Request):
                  token = request.headers.get("Authorization")  # no validation
                  if token != "supersecrettoken":
                      return {"error": "unauthorized"}
                  return {"status": "ok"}
          - compliant: |
              from fastapi import Depends, FastAPI
              from fastapi.security import OAuth2PasswordBearer

              oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
              app = FastAPI()

              @app.get("/secure")
              async def secure_route(token: str = Depends(oauth2_scheme)):
                  return {"token": token}

      - title: "Configure SSL Context Properly in Application Code"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/deployment/https/"
        description: |
          Applications that configure SSL must set proper SSL context and security settings in the application code.
        impact: |
          Proper SSL configuration ensures encrypted transmission of credentials and sensitive data, and meets standard compliance requirements such as OWASP and GDPR.
        code_examples:
          - non_compliant: |
              import uvicorn
              from fastapi import FastAPI

              app = FastAPI()

              if __name__ == "__main__":
                  # SSL configuration without proper context
                  uvicorn.run(app, host="0.0.0.0", port=8443, ssl_keyfile="key.pem", ssl_certfile="cert.pem")
          - compliant: |
              import ssl
              import uvicorn
              from fastapi import FastAPI

              app = FastAPI()

              if __name__ == "__main__":
                  ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
                  ssl_context.load_cert_chain("cert.pem", "key.pem")
                  ssl_context.set_ciphers("ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS")
                  uvicorn.run(app, host="0.0.0.0", port=8443, ssl=ssl_context)

      - title: "Use `fastapi.security` for Standard Schemes"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/security/"
        description: |
          Authentication mechanisms must be implemented using classes from the `fastapi.security` module, such as `OAuth2PasswordBearer`, `APIKeyHeader`, or `HTTPBasic`.
        impact: |
          Built-in security utilities offer battle-tested implementations, automatic OpenAPI documentation, and standard behavior across APIs. Manual parsing is error-prone and often lacks proper validation, fallback behavior, and consistency.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Request

              app = FastAPI()

              @app.get("/admin")
              async def admin_access(request: Request):
                  token = request.headers.get("Authorization")
                  if not token or not token.startswith("Bearer "):
                      return {"error": "unauthorized"}
                  return {"status": "authorized"}
          - compliant: |
              from fastapi import FastAPI, Depends
              from fastapi.security import OAuth2PasswordBearer

              app = FastAPI()
              oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

              @app.get("/admin")
              async def admin_access(token: str = Depends(oauth2_scheme)):
                  return {"status": "authorized"}

      - title: "Enable CORS with Allowed Origins Only"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/cors/"
        description: |
          Enable Cross-Origin Resource Sharing (CORS) using FastAPI's `CORSMiddleware`, and explicitly set a list of allowed origins.
        impact: |
          Misconfigured CORS allows unauthorized websites to interact with your API, exposing users to CSRF and token leakage. Restricting origins mitigates unauthorized access and enforces security boundaries.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              from fastapi.middleware.cors import CORSMiddleware

              app = FastAPI()
              app.add_middleware(
                  CORSMiddleware,
                  allow_origins=["*"],  # insecure wildcard
                  allow_credentials=True,
                  allow_methods=["*"],
                  allow_headers=["*"],
              )
          - compliant: |
              from fastapi import FastAPI
              from fastapi.middleware.cors import CORSMiddleware

              app = FastAPI()
              app.add_middleware(
                  CORSMiddleware,
                  allow_origins=["https://frontend.example.com", "https://admin.example.com"],
                  allow_credentials=True,
                  allow_methods=["GET", "POST", "PUT", "DELETE"],
                  allow_headers=["Authorization", "Content-Type"],
              )

      - title: "Set Security Headers via Middleware"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          FastAPI apps should send security headers like `Content-Security-Policy`, `X-Frame-Options`, and `X-Content-Type-Options`.
        impact: |
          Missing security headers leave APIs and web frontends exposed to client-side vulnerabilities. Sending strict headers strengthens API hardening and improves browser enforcement.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/")
              async def home():
                  return {"msg": "no headers set"}
          - compliant: |
              from fastapi import FastAPI
              from starlette.middleware.base import BaseHTTPMiddleware

              class SecurityHeadersMiddleware(BaseHTTPMiddleware):
                  async def dispatch(self, request, call_next):
                      response = await call_next(request)
                      response.headers["Content-Security-Policy"] = "default-src 'none'"
                      response.headers["X-Frame-Options"] = "DENY"
                      response.headers["X-Content-Type-Options"] = "nosniff"
                      return response

              app = FastAPI()
              app.add_middleware(SecurityHeadersMiddleware)

      - title: "Avoid Use of `eval()` and `exec()` Anywhere in Application Code"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/security/"
        description: |
          The use of `eval()`, `exec()`, or `ast.literal_eval()` on user input or config sources is strictly prohibited.
        impact: |
          Dynamic code execution is a major attack surface. Even sanitized inputs can lead to remote code execution (RCE) in containerized or serverless environments. Avoid altogether.
        code_examples:
          - non_compliant: |
              def unsafe_eval(expression: str):
                  return eval(expression)
          - compliant: |
              import numexpr

              def safe_eval(expression: str):
                  return numexpr.evaluate(expression)

      - title: "Sanitize User Input Before Logging or Reflection"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/security/"
        description: |
          Never log raw user input or echo it back in responses without sanitization.
        impact: |
          Unsanitized input can lead to log injection, reflected XSS, or log pollution in multi-tenant systems. Always strip or encode input before use in logs or dynamic responses.
        code_examples:
          - non_compliant: |
              import logging
              from fastapi import FastAPI, Request

              app = FastAPI()

              @app.get("/search")
              async def search(request: Request, query: str):
                  logging.info(f"user search: {query}")  # unsafe logging
                  return {"query": query}
          - compliant: |
              import logging
              import html
              from fastapi import FastAPI, Request

              app = FastAPI()

              @app.get("/search")
              async def search(request: Request, query: str):
                  safe_query = html.escape(query).replace('\n', '\\n').replace('\r', '')
                  logging.info(f"user search: {safe_query}")
                  return {"query": safe_query}

      - title: "Validate File Types and Size Limits on Upload"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/request-files/"
        description: |
          Uploaded files must be checked for allowed MIME types and enforced maximum file size.
        impact: |
          Insecure upload handling can lead to RCE, disk exhaustion, or malware propagation. Strict validation prevents exploitation via crafted files.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, File, UploadFile

              app = FastAPI()

              @app.post("/upload")
              async def upload(file: UploadFile = File(...)):
                  contents = await file.read()
                  return {"size": len(contents)}
          - compliant: |
              from fastapi import FastAPI, File, UploadFile, HTTPException

              app = FastAPI()

              @app.post("/upload")
              async def upload(file: UploadFile = File(...)):
                  allowed_types = ["image/png", "image/jpeg", "application/pdf"]
                  if file.content_type not in allowed_types:
                      raise HTTPException(status_code=415, detail="Unsupported file type")
                  
                  contents = await file.read()
                  if len(contents) > 5 * 1024 * 1024:  # 5MB limit
                      raise HTTPException(status_code=413, detail="File too large")
                  
                  return {"size": len(contents), "type": file.content_type}

      - title: "Load Secrets via Environment Variables, Never Hardcode"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/settings/"
        description: |
          Never hardcode passwords, tokens, or keys in `.py` files. Load them securely from environment variables, secrets managers, or `.env` files.
        impact: |
          Prevents credential leaks, supports safe rotation, and avoids secret exposure in version control.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()
              API_KEY = "sk-test-abc123"  # hardcoded secret
              DATABASE_URL = "postgresql://user:password@localhost/db"
          - compliant: |
              import os
              from fastapi import FastAPI

              app = FastAPI()
              API_KEY = os.environ["STRIPE_SECRET_KEY"]
              DATABASE_URL = os.environ["DATABASE_URL"]

      - title: "Avoid Logging PII"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/security/"
        description: |
          Never log sensitive information such as user emails, passwords, session tokens, or API keys—even in debug mode.
        impact: |
          Logging PII violates data privacy laws (e.g., GDPR), creates legal liability, and may leak credentials during incidents or log access.
        code_examples:
          - non_compliant: |
              import logging
              from fastapi import FastAPI

              app = FastAPI()

              @app.post("/login")
              async def login(email: str, password: str):
                  logging.info(f"Login attempt for {email} with password {password}")  # PII in log
                  return {"status": "ok"}
          - compliant: |
              import logging
              from fastapi import FastAPI

              app = FastAPI()

              @app.post("/login")
              async def login(email: str, password: str):
                  logging.info("Login attempt received")  # no sensitive data
                  return {"status": "ok"}

      - title: "Validate and Document Required HTTP Headers"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/dependencies/"
        description: |
          Use FastAPI's dependency injection to declare and validate required headers.
        impact: |
          Makes required headers explicit in OpenAPI, prevents invalid requests, and supports better observability and client enforcement.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, Request

              app = FastAPI()

              @app.get("/items")
              async def get_items(request: Request):
                  version = request.headers.get("X-API-Version")
                  if not version:
                      return {"error": "Missing API version"}
                  return {"items": [], "version": version}
          - compliant: |
              from fastapi import FastAPI, Header, Depends

              app = FastAPI()

              def api_version(x_api_version: str = Header(..., alias="X-API-Version")):
                  return x_api_version

              @app.get("/items")
              async def get_items(x_api_version: str = Depends(api_version)):
                  return {"items": [], "version": x_api_version}

  - name: "FastAPI - Rate Limiting and Protection"
    paths:
      - '**/*.py'
    policies:
      - title: "Apply Middleware for Rate Limiting"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          FastAPI applications must integrate rate limiting using middleware like `slowapi`, `limits`, or a Redis-based strategy.
        impact: |
          Without rate limiting, APIs are vulnerable to excessive requests from a single client or bot, leading to degraded performance, downtime, or overuse of resources. Middleware ensures scalable, fair access and protects against abuse.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/data")
              async def get_data():
                  return {"message": "No rate limit applied"}  # unsafe
          - compliant: |
              from fastapi import FastAPI, Request
              from slowapi import Limiter, _rate_limit_exceeded_handler
              from slowapi.util import get_remote_address
              from slowapi.errors import RateLimitExceeded

              limiter = Limiter(key_func=get_remote_address)
              app = FastAPI()
              app.state.limiter = limiter
              app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

              @app.get("/data")
              @limiter.limit("5/minute")
              async def get_data(request: Request):
                  return {"message": "This route is rate-limited"}

      - title: "Protect Auth and Payment Endpoints with Stricter Limits"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Authentication and payment endpoints must have a rate limit of 5 requests per minute or lower.
        impact: |
          Sensitive endpoints are prime targets for brute-force and abuse. Endpoint-specific limits reduce risk while preserving usability elsewhere.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              from pydantic import BaseModel

              app = FastAPI()

              class LoginData(BaseModel):
                  username: str
                  password: str

              @app.post("/login")
              async def login(credentials: LoginData):
                  return await authenticate_user(credentials)
          - compliant: |
              from fastapi import FastAPI, Request
              from slowapi import Limiter
              from slowapi.util import get_remote_address
              from pydantic import BaseModel

              limiter = Limiter(key_func=get_remote_address)
              app = FastAPI()

              class LoginData(BaseModel):
                  username: str
                  password: str

              @app.post("/login")
              @limiter.limit("5/minute")
              async def login(request: Request, credentials: LoginData):
                  return await authenticate_user(credentials)

      - title: "Enforce Request Body Size Limits via Middleware"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Middleware must enforce JSON or file body size limits.
        impact: |
          Request body size limits reduce DoS risk and protect async event loop from large unbounded payloads that could exhaust server resources. This is essential for rate limiting and abuse protection strategies.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.post("/upload")
              async def upload(payload: dict):
                  return {"received": len(str(payload))}
          - compliant: |
              from fastapi import FastAPI
              from starlette.middleware.base import BaseHTTPMiddleware
              from starlette.responses import JSONResponse

              class BodySizeLimitMiddleware(BaseHTTPMiddleware):
                  async def dispatch(self, request, call_next):
                      content_length = request.headers.get("content-length")
                      if content_length and int(content_length) > 1024 * 1024:  # 1MB limit
                          return JSONResponse(
                              status_code=413,
                              content={"detail": "Request body too large"}
                          )
                      return await call_next(request)

              app = FastAPI()
              app.add_middleware(BodySizeLimitMiddleware)

              @app.post("/upload")
              async def upload(payload: dict):
                  return {"received": len(str(payload))}

  - name: "FastAPI - Documentation and OpenAPI"
    paths:
      - '**/*.py'
    policies:
      - title: "Add Descriptive Summary and Description in Endpoints"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/path-operation-configuration/"
        description: |
          Each FastAPI route should define a `summary` and `description` argument in route decorators.
        impact: |
          Well-documented APIs improve developer experience, enable automated client generation, and reduce the need for external documentation. Summary and description fields provide clarity to users consuming the OpenAPI schema or Swagger UI.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  return [{"id": 1, "name": "Alice"}]
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get(
                  "/users",
                  summary="List all users",
                  description="Fetches and returns a list of all registered users in the system."
              )
              async def get_users():
                  return [{"id": 1, "name": "Alice"}]

      - title: "Include Example Responses in Route Declarations"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/path-operation-configuration/"
        description: |
          Each route should include example responses using the `response_model` and `responses` parameter with detailed examples.
        impact: |
          Providing example responses improves API discoverability and sets clear expectations for consumers. It enhances the OpenAPI output, helps frontend developers, and assists in contract testing.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/status")
              async def get_status():
                  return {"status": "ok"}
          - compliant: |
              from fastapi import FastAPI
              from pydantic import BaseModel

              app = FastAPI()

              class StatusResponse(BaseModel):
                  status: str

              @app.get(
                  "/status",
                  response_model=StatusResponse,
                  responses={
                      200: {
                          "description": "Status check response",
                          "content": {
                              "application/json": {
                                  "example": {"status": "ok"}
                              }
                          }
                      }
                  }
              )
              async def get_status():
                  return {"status": "ok"}

      - title: "Add Contact and License Info in OpenAPI Schema"
        severity: low
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/metadata/"
        description: |
          Include `contact`, `license`, and `termsOfService` metadata in the FastAPI OpenAPI schema.
        impact: |
          Providing full API metadata supports trust, discoverability, and compliance in enterprise or public-facing APIs.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI(
                  title="My API",
                  version="1.0.0"
              )  # missing contact, license, and termsOfService metadata
          - compliant: |
              from fastapi import FastAPI

              app = FastAPI(
                  title="My API",
                  version="1.0.0",
                  contact={
                      "name": "Support Team",
                      "email": "support@example.com"
                  },
                  license_info={
                      "name": "MIT",
                      "url": "https://opensource.org/licenses/MIT"
                  },
                  terms_of_service="https://example.com/terms"
              )

      - title: "Document All Request and Response Fields with Field Descriptions"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/body/"
        description: |
          Every field in Pydantic models used for requests or responses should include a `description` via `Field(...)`.
        impact: |
          Field-level descriptions improve generated docs, SDK generation, and frontend API consumption. They reduce guesswork for external teams.
        code_examples:
          - non_compliant: |
              from pydantic import BaseModel

              class User(BaseModel):
                  id: int
                  name: str
                  email: str
          - compliant: |
              from pydantic import BaseModel, Field

              class User(BaseModel):
                  id: int = Field(..., description="Unique user identifier")
                  name: str = Field(..., description="User's display name")
                  email: str = Field(..., description="User's email address")

  - name: "FastAPI - Error Handling and RFC 7807"
    paths:
      - '**/*.py'
    policies:
      - title: "Use `RequestValidationError` and `HTTPException` Handlers"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/handling-errors/"
        description: |
          Define custom exception handlers for `RequestValidationError` and `HTTPException` using FastAPI's `@app.exception_handler`.
        impact: |
          Centralized error handling improves API robustness and client experience by returning structured responses, hiding stack traces, and ensuring all errors follow a standard format.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, HTTPException

              app = FastAPI()

              @app.get("/items/{item_id}")
              async def read_item(item_id: int):
                  if item_id > 100:
                      raise HTTPException(status_code=400, detail="Item ID too high")
                  return {"item_id": item_id}
              # No custom exception handlers defined
          - compliant: |
              from fastapi import FastAPI, HTTPException, Request
              from fastapi.responses import JSONResponse
              from fastapi.exceptions import RequestValidationError

              app = FastAPI()

              @app.exception_handler(HTTPException)
              async def http_exception_handler(request: Request, exc: HTTPException):
                  return JSONResponse(
                      status_code=exc.status_code,
                      content={"detail": exc.detail, "path": str(request.url)}
                  )

              @app.exception_handler(RequestValidationError)
              async def validation_exception_handler(request: Request, exc: RequestValidationError):
                  return JSONResponse(
                      status_code=422,
                      content={"detail": exc.errors(), "path": str(request.url)}
                  )

              @app.get("/items/{item_id}")
              async def read_item(item_id: int):
                  if item_id > 100:
                      raise HTTPException(status_code=400, detail="Item ID too high")
                  return {"item_id": item_id}

      - title: "Return Problem+JSON Format in Errors"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/handling-errors/"
        description: |
          Error responses must use the RFC 7807 problem+json format with fields like `type`, `title`, `status`, and `detail`.
        impact: |
          Returning standardized problem responses ensures consistent error handling, improves API interoperability, and allows clients to programmatically interpret and handle different failure cases.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI, HTTPException

              app = FastAPI()

              @app.get("/fail")
              async def fail():
                  raise HTTPException(status_code=400, detail="Invalid input")
          - compliant: |
              from fastapi import FastAPI, Request
              from fastapi.responses import JSONResponse
              from starlette.exceptions import HTTPException as StarletteHTTPException

              app = FastAPI()

              @app.exception_handler(StarletteHTTPException)
              async def http_exception_handler(request: Request, exc: StarletteHTTPException):
                  return JSONResponse(
                      status_code=exc.status_code,
                      content={
                          "type": "https://example.com/errors/http-error",
                          "title": "HTTP Error",
                          "status": exc.status_code,
                          "detail": str(exc.detail)
                      },
                      media_type="application/problem+json"
                  )

              @app.get("/fail")
              async def fail():
                  raise HTTPException(status_code=400, detail="Invalid input")

  - name: "FastAPI - Background Tasks"
    paths:
      - '**/*.py'
    policies:
      - title: "Use `BackgroundTasks` or `Celery` for Long Operations"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/background-tasks/"
        description: |
          Long-running operations must be offloaded using `BackgroundTasks`, `Celery`, `Dramatiq`, or `asyncio.create_task()`.
        impact: |
          Offloading heavy logic keeps HTTP responses fast, avoids timeout errors, and improves user experience. It also allows retry logic, scheduling, and better fault tolerance in background workloads.
        code_examples:
          - non_compliant: |
              import time
              from fastapi import FastAPI

              app = FastAPI()

              @app.post("/notify")
              async def send_notification(email: str):
                  time.sleep(5)  # blocks response
                  print(f"Email sent to {email}")
                  return {"status": "email sent"}
          - compliant: |
              import time
              from fastapi import FastAPI, BackgroundTasks

              app = FastAPI()

              def send_email(user_email: str):
                  time.sleep(5)  # simulate email sending
                  print(f"Email sent to {user_email}")

              @app.post("/notify")
              async def send_notification(email: str, background_tasks: BackgroundTasks):
                  background_tasks.add_task(send_email, email)
                  return {"status": "queued"}

      - title: "Include Retry and Monitoring in Background Tasks"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/background-tasks/"
        description: |
          All tasks that use `BackgroundTasks`, Celery, or `create_task()` must include logging, error handling, and retry behavior.
        impact: |
          Unmonitored background jobs can silently fail and corrupt data or user experience. Observability and retry improve reliability in async processing pipelines.
        code_examples:
          - non_compliant: |
              from fastapi import BackgroundTasks

              def send_email(email: str):
                  # Email sending logic without error handling
                  print(f"Sending email to {email}")

              background_tasks = BackgroundTasks()
              background_tasks.add_task(send_email, "user@example.com")
          - compliant: |
              import logging
              import asyncio
              from fastapi import BackgroundTasks

              def send_email(user_email: str):
                  if not user_email:
                      raise ValueError("Email address required")
                  print(f"Sending email to {user_email}")

              def safe_email_task(email: str):
                  try:
                      send_email(email)
                      logging.info(f"Email sent successfully to {email}")
                  except Exception as e:
                      logging.error(f"Email failed: {str(e)}")
                      # Schedule retry
                      asyncio.create_task(retry_email_later(email))

              async def retry_email_later(email: str):
                  await asyncio.sleep(60)  # Wait 1 minute before retry
                  try:
                      send_email(email)
                      logging.info(f"Email retry successful for {email}")
                  except Exception as e:
                      logging.error(f"Email retry failed for {email}: {str(e)}")

              background_tasks = BackgroundTasks()
              background_tasks.add_task(safe_email_task, "user@example.com")

      - title: "Track and Cancel Detached Background Tasks"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/background-tasks/"
        description: |
          Store references to background tasks started with `create_task()`.
        impact: |
          Prevents zombie workers, memory leaks, and uncontrolled execution in high-load async servers.
        code_examples:
          - non_compliant: |
              import asyncio
              from fastapi import FastAPI

              app = FastAPI()

              async def slow_op():
                  await asyncio.sleep(10)
                  return "done"

              @app.get("/start-task")
              async def start_task():
                  asyncio.create_task(slow_op())  # fire and forget
                  return {"status": "started"}
          - compliant: |
              import asyncio
              from fastapi import FastAPI

              app = FastAPI()
              active_tasks = []

              async def slow_op():
                  await asyncio.sleep(10)
                  return "done"

              @app.get("/start-task")
              async def start_task():
                  task = asyncio.create_task(slow_op())
                  active_tasks.append(task)
                  return {"status": "started"}

              @app.on_event("shutdown")
              async def shutdown():
                  for task in active_tasks:
                      task.cancel()
                      try:
                          await task
                      except asyncio.CancelledError:
                          pass

  - name: "FastAPI - Database Access Layer"
    paths:
      - '**/*.py'
    policies:
      - title: "Use SQLAlchemy 2.x or SQLModel with Async Engines"
        severity: mandatory
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/sql-databases/"
        description: |
          FastAPI projects must use SQLAlchemy 2.x or SQLModel with asynchronous engines and sessions.
        impact: |
          Synchronous database engines block the event loop and undermine FastAPI's async performance model. SQLAlchemy 2.x async and SQLModel provide clean, typed async ORM support for scalable, non-blocking database access.
        code_examples:
          - non_compliant: |
              from sqlalchemy import create_engine
              from sqlalchemy.orm import sessionmaker

              # Synchronous database setup
              engine = create_engine("sqlite:///db.sqlite")
              SessionLocal = sessionmaker(bind=engine)

              def get_session():
                  return SessionLocal()
          - compliant: |
              from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
              from sqlmodel import SQLModel

              # Asynchronous database setup
              engine = create_async_engine("sqlite+aiosqlite:///db.sqlite", echo=True)
              SessionLocal = async_sessionmaker(engine)

              async def init_db():
                  async with engine.begin() as conn:
                      await conn.run_sync(SQLModel.metadata.create_all)

              async def get_session():
                  async with SessionLocal() as session:
                      yield session

      - title: "Encapsulate Queries in Repository Classes"
        severity: high
        required_context: multi-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/sql-databases/"
        description: |
          Business logic should not directly embed database queries inside route handlers. Instead, use repository or service classes to abstract and organize data access logic separately from API layer code.
        impact: |
          Encapsulation improves separation of concerns, testability, and long-term maintainability. It allows unit testing of DB operations independently from route handlers and reduces duplication across modules.
        code_examples:
          - non_compliant: |
              from sqlmodel import select
              from sqlalchemy.ext.asyncio import AsyncSession
              from fastapi import FastAPI, Depends

              app = FastAPI()

              @app.get("/users/{user_id}")
              async def get_user(user_id: int, session: AsyncSession = Depends(get_session)):
                  # Direct database query in route handler
                  result = await session.execute(select(User).where(User.id == user_id))
                  user = result.scalar_one_or_none()
                  if not user:
                      raise HTTPException(status_code=404, detail="User not found")
                  return user
          - compliant: |
              # repositories/user_repository.py
              from sqlmodel import select
              from sqlalchemy.ext.asyncio import AsyncSession

              class UserRepository:
                  def __init__(self, session: AsyncSession):
                      self.session = session

                  async def get_user_by_id(self, user_id: int):
                      result = await self.session.execute(select(User).where(User.id == user_id))
                      return result.scalar_one_or_none()

              # routes/users.py
              from fastapi import FastAPI, Depends, HTTPException

              app = FastAPI()

              @app.get("/users/{user_id}")
              async def get_user(user_id: int, session: AsyncSession = Depends(get_session)):
                  repo = UserRepository(session)
                  user = await repo.get_user_by_id(user_id)
                  if not user:
                      raise HTTPException(status_code=404, detail="User not found")
                  return user

  - name: "FastAPI - Testing and Testability"
    paths:
      - 'tests/**/*.py'
    policies:
      - title: "Use `pytest` and `TestClient` for Integration Tests"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/testing/"
        description: |
          Use `pytest` along with FastAPI's built-in `TestClient` to perform integration testing of API endpoints.
        impact: |
          `pytest` offers robust features, fixtures, and plugin support. Using `TestClient` ensures reliable in-process testing of FastAPI routes, preserving dependency injection and routing behavior without needing external servers.
        code_examples:
          - non_compliant: |
              import requests
              from fastapi import FastAPI

              app = FastAPI()

              def test_get_items():
                  response = requests.get("http://localhost:8000/items")
                  assert response.status_code == 200
          - compliant: |
              import pytest
              from fastapi.testclient import TestClient
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/items")
              async def get_items():
                  return {"items": []}

              client = TestClient(app)

              def test_get_items():
                  response = client.get("/items")
                  assert response.status_code == 200
                  assert response.json() == {"items": []}

      - title: "Override Dependencies During Tests"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/testing/"
        description: |
          Use `app.dependency_overrides` to replace dependencies with test doubles during testing.
        impact: |
          Dependency overrides enable isolated unit testing by replacing real dependencies (databases, external APIs) with mocks or test implementations, ensuring tests are fast, reliable, and don't affect external systems.
        code_examples:
          - non_compliant: |
              from fastapi.testclient import TestClient
              from fastapi import FastAPI, Depends

              def get_database():
                  return real_database_connection()

              app = FastAPI()

              @app.get("/users")
              async def get_users(db = Depends(get_database)):
                  return db.query_users()

              client = TestClient(app)

              def test_get_users():
                  # This will use real database
                  response = client.get("/users")
                  assert response.status_code == 200
          - compliant: |
              from fastapi.testclient import TestClient
              from fastapi import FastAPI, Depends

              def get_database():
                  return real_database_connection()

              def get_test_database():
                  return mock_database_connection()

              app = FastAPI()

              @app.get("/users")
              async def get_users(db = Depends(get_database)):
                  return db.query_users()

              app.dependency_overrides[get_database] = get_test_database
              client = TestClient(app)

              def test_get_users():
                  response = client.get("/users")
                  assert response.status_code == 200

      - title: "Avoid Shared State Between Test Cases"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/testing/"
        description: |
          Each test must run in isolation with fresh data, 
          without using any shared global variables or in-memory structures across test cases.
        impact: |
          Shared state leads to flaky tests, false positives, and debugging complexity. Isolated tests are more stable, parallel-safe, and CI-compliant.
        code_examples:
          - non_compliant: |
              test_data = []

              def test_one():
                  test_data.append("a")
                  assert len(test_data) == 1

              def test_two():
                  test_data.append("b")
                  assert len(test_data) == 1  # This will fail if test_one runs first
          - compliant: |
              def test_one():
                  data = []
                  data.append("a")
                  assert len(data) == 1

              def test_two():
                  data = []
                  data.append("b")
                  assert len(data) == 1

  - name: "FastAPI - Performance and Optimization"
    paths:
      - '**/*.py'
    policies:
      - title: "Use Connection Pooling for Database Connections"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/sql-databases/"
        description: |
          Database connections must use connection pooling.
        impact: |
          Connection pooling dramatically improves performance by reusing database connections, reduces connection establishment overhead, and prevents connection leaks in high-traffic applications.
        code_examples:
          - non_compliant: |
              from sqlalchemy.ext.asyncio import create_async_engine
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/users")
              async def get_users():
                  # Creating new engine each time
                  engine = create_async_engine("postgresql+asyncpg://user:pass@localhost/db")
                  async with engine.begin() as conn:
                      result = await conn.execute("SELECT * FROM users")
                      return {"users": result.fetchall()}
          - compliant: |
              from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
              from sqlalchemy.pool import QueuePool
              from fastapi import FastAPI, Depends

              # Configure engine with connection pooling
              engine = create_async_engine(
                  "postgresql+asyncpg://user:pass@localhost/db",
                  poolclass=QueuePool,
                  pool_size=20,
                  max_overflow=30,
                  pool_recycle=3600
              )
              SessionLocal = async_sessionmaker(engine)

              async def get_session():
                  async with SessionLocal() as session:
                      yield session

              app = FastAPI()

              @app.get("/users")
              async def get_users(session = Depends(get_session)):
                  # Uses pooled connection
                  result = await session.execute("SELECT * FROM users")
                  return {"users": result.fetchall()}

      - title: "Implement Response Compression"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Enable GZip compression middleware for responses.
        impact: |
          Response compression reduces bandwidth usage, improves response times for clients, and enhances overall API performance especially for large JSON responses.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/large-data")
              async def get_large_data():
                  return {"data": ["item"] * 10000}  # Large uncompressed response
          - compliant: |
              from fastapi import FastAPI
              from fastapi.middleware.gzip import GZipMiddleware

              app = FastAPI()
              app.add_middleware(GZipMiddleware, minimum_size=1000)

              @app.get("/large-data")
              async def get_large_data():
                  return {"data": ["item"] * 10000}  # Compressed response

      - title: "Use Streaming Responses for Large Data"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/custom-response/"
        description: |
          Use `StreamingResponse` for large files or data sets.
        impact: |
          Streaming responses prevent memory exhaustion when serving large files, improve response time for large datasets, and enable better resource utilization in high-concurrency scenarios.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI

              app = FastAPI()

              @app.get("/large-file")
              async def download_large_file():
                  with open("large_file.csv", "rb") as f:
                      content = f.read()  # Loads entire file into memory
                  return content
          - compliant: |
              from fastapi import FastAPI
              from fastapi.responses import StreamingResponse
              import io

              app = FastAPI()

              @app.get("/large-file")
              async def download_large_file():
                  def generate():
                      with open("large_file.csv", "rb") as f:
                          while chunk := f.read(8192):
                              yield chunk
                  
                  return StreamingResponse(generate(), media_type="text/csv"
                  )

  - name: "FastAPI - Logging and Monitoring"
    paths:
      - '**/*.py'
    policies:
      - title: "Use Structured JSON Logging"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/tutorial/handling-errors/"
        description: |
          Configure logging to output structured JSON format.
        impact: |
          Structured logging enables better log analysis, monitoring integration, and debugging capabilities. JSON format allows easy parsing by log aggregation systems.
        code_examples:
          - non_compliant: |
              import logging
              from fastapi import FastAPI

              app = FastAPI()
              
              logging.basicConfig(level=logging.INFO)
              logger = logging.getLogger(__name__)

              @app.get("/users")
              async def get_users():
                  logger.info("Getting users")  # Plain text logging
                  return {"users": []}
          - compliant: |
              import logging
              import json
              from fastapi import FastAPI

              class JSONFormatter(logging.Formatter):
                  def format(self, record):
                      return json.dumps({
                          "timestamp": self.formatTime(record),
                          "level": record.levelname,
                          "message": record.getMessage(),
                          "module": record.module
                      })

              app = FastAPI()
              
              handler = logging.StreamHandler()
              handler.setFormatter(JSONFormatter())
              logger = logging.getLogger(__name__)
              logger.addHandler(handler)
              logger.setLevel(logging.INFO)

              @app.get("/users")
              async def get_users():
                  logger.info("Getting users")  # Structured JSON logging
                  return {"users": []}

      - title: "Add Request ID Correlation in Logs"
        severity: high
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Include correlation IDs in all log entries to trace requests across the application.
        impact: |
          Request correlation enables tracing requests through distributed systems, simplifies debugging, and improves observability in production environments.
        code_examples:
          - non_compliant: |
              import logging
              from fastapi import FastAPI, Request

              app = FastAPI()
              logger = logging.getLogger(__name__)

              @app.get("/process")
              async def process_request(request: Request):
                  request_id = request.headers.get("X-Request-ID", "N/A")
                  logger.info(f"Processing request with ID: {request_id}")  # No correlation ID
                  logger.info("Request completed")
                  return {"status": "processed"}
          - compliant: |
              import logging
              import uuid
              from fastapi import FastAPI, Request
              from starlette.middleware.base import BaseHTTPMiddleware

              class RequestIDMiddleware(BaseHTTPMiddleware):
                  async def dispatch(self, request, call_next):
                      request_id = str(uuid.uuid4())
                      request.state.request_id = request_id
                      response = await call_next(request)
                      response.headers["X-Request-ID"] = request_id
                      return response

              app = FastAPI()
              app.add_middleware(RequestIDMiddleware)
              logger = logging.getLogger(__name__)

              @app.get("/process")
              async def process_request(request: Request):
                  request_id = request.state.request_id
                  logger.info(f"Processing request {request_id}")
                  logger.info(f"Request {request_id} completed")
                  return {"status": "processed"}

      - title: "Log Performance Metrics for Slow Endpoints"
        severity: medium
        required_context: single-file
        software_version: "0.116.1"
        reference_link: "https://fastapi.tiangolo.com/advanced/middleware/"
        description: |
          Log response times for all endpoints.
        impact: |
          Performance logging helps identify bottlenecks, enables proactive optimization, and supports performance monitoring in production environments.
        code_examples:
          - non_compliant: |
              from fastapi import FastAPI
              import time

              app = FastAPI()

              @app.get("/slow-endpoint")
              async def slow_endpoint():
                  time.sleep(2)  # Simulate slow operation
                  return {"data": "result"}
          - compliant: |
              from fastapi import FastAPI, Request
              from starlette.middleware.base import BaseHTTPMiddleware
              import time
              import logging

              logger = logging.getLogger(__name__)

              class PerformanceLoggingMiddleware(BaseHTTPMiddleware):
                  async def dispatch(self, request, call_next):
                      start_time = time.time()
                      response = await call_next(request)
                      process_time = time.time() - start_time
                      
                      if process_time > 1.0:  # Log slow requests
                          logger.warning(f"Slow request: {request.url.path} took {process_time:.2f}s")
                      
                      response.headers["X-Process-Time"] = str(process_time)
                      return response

              app = FastAPI()
              app.add_middleware(PerformanceLoggingMiddleware)

              @app.get("/slow-endpoint")
              async def slow_endpoint():
                  time.sleep(2)  # Simulate slow operation
                  return {"data": "result"}
